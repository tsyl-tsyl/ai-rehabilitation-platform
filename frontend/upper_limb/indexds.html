<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½ä¸Šè‚¢åº·å¤è®­ç»ƒç³»ç»Ÿ | Smart Upper Limb Rehabilitation</title>
    <script src="../libs/tailwindcss/tailwindcss.js"></script>
    <link rel="stylesheet" href="../libs/font-awesome/all.min.css">
    <script src="../libs/chart/chart.js"></script>
    <!-- MediaPipe -->
    <script src="../libs/mediapipe/camera_utils.js"></script>
    <script src="../libs/mediapipe/drawing_utils.js"></script>
    <script src="../libs/mediapipe/pose.js"></script>
    <script src="../static/js/common.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#0066CC',
                        secondary: '#1E88E5',
                        accent: '#64B5F6',
                        dark: '#0D47A1',
                        light: '#E3F2FD',
                        deep: '#0A3A7A',
                        med: '#1565C0',
                        success: '#10B981',
                        warning: '#F59E0B',
                        danger: '#EF4444',
                        bronze: '#CD7F32',
                        silver: '#C0C0C0',
                        gold: '#FFD700'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    }
                },
            }
        }
    </script>
    
    <style>
        .card-gradient {
            background: linear-gradient(135deg, #1E88E5 0%, #0D47A1 100%);
        }
        .border-glow {
            box-shadow: 0 0 15px rgba(100, 181, 246, 0.5);
        }
        .fade-in {
            animation: fadeIn 1s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .progress-container {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 6px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 10px;
            transition: width 0.4s ease;
        }
        
        .temp-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s;
            animation-fill-mode: forwards;
        }

        .temp-message.success {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        .temp-message.error {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .temp-message.info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .temp-message.warning {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #000;
            min-height: 480px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .video-placeholder {
            text-align: center;
            padding: 20px;
        }

        .video-placeholder i {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.7;
        }

        .action-btn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .action-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .action-btn:hover::after {
            left: 100%;
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            color: white;
        }
        
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            height: 300px;
        }

        .exercise-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .exercise-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .exercise-card.active {
            border-color: #4facfe;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.5);
        }

        .exercise-card.completed {
            background: rgba(16, 185, 129, 0.2);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e1e5e9;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0;
        }
        
        .modal-title {
            margin: 0;
            color: white;
            font-size: 1.5rem;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: white;
            width: auto;
            padding: 5px;
            transition: transform 0.2s;
        }
        
        .close-btn:hover {
            transform: scale(1.1);
        }

        .lang-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
        }
        
        .lang-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* æ–°å¢æ ·å¼ */
        .target-pose-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .step-dot.active {
            background: #4facfe;
            transform: scale(1.2);
        }

        .step-dot.completed {
            background: #10B981;
        }

        .achievement-badge {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #7c2d12;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin: 5px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .rest-reminder {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            animation: pulse 2s infinite;
        }

        .progress-visualization {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }

        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .quality-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #EF4444, #F59E0B, #10B981);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .visual-guide {
            position: absolute;
            border: 2px dashed #4facfe;
            border-radius: 10px;
            pointer-events: none;
            z-index: 5;
            animation: guidePulse 3s infinite;
        }

        @keyframes guidePulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .smart-training-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .smart-training-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .enhanced-feedback {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #4facfe;
        }

        .technical-tips {
            background: rgba(16, 185, 129, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
        }

        /* æ–°å¢æ ·å¼ï¼šæˆå°±æ˜¾ç¤ºåœ¨è§†é¢‘ä¸Šæ–¹ */
        .achievements-overlay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            max-width: 90%;
        }

        /* æ–°å¢æ ·å¼ï¼šæŒ‰é’®æ–‡å­—æ ·å¼ */
        .btn-text {
            margin-left: 8px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-deep to-med min-h-screen text-white overflow-x-hidden">
    <!-- é¡¶éƒ¨è¿›åº¦æ¡ -->
    <div class="absolute top-0 left-0 right-0 h-1 bg-accent"></div>
    
    <div class="container mx-auto px-4 py-8 relative z-10">
        <!-- å¤´éƒ¨ -->
        <header class="flex justify-between items-center mb-8 fade-in">
            <div class="flex items-center">
                <a href="#" class="w-10 h-10 rounded-full bg-white/10 flex items-center justify-center mr-3 hover:bg-white/20 transition-colors" title="è¿”å›é¦–é¡µ">
                    <i class="fas fa-home text-xl text-light"></i>
                </a>
                <div class="text-xl font-semibold" id="page-title">ä¸Šè‚¢åº·å¤è®­ç»ƒç³»ç»Ÿ</div>
            </div>
            <div class="flex items-center">
                <div class="text-right mr-4">
                    <div class="text-sm opacity-80" id="page-subtitle">åŸºäºAIæ¨¡å‹çš„ä¸Šè‚¢åº·å¤è®­ç»ƒä¸è¯„ä¼°å¹³å°</div>
                </div>
                <button class="lang-btn" onclick="toggleLanguage()">
                    <span id="lang-text">English</span>
                </button>
            </div>
        </header>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- å·¦ä¾§ï¼šæ‘„åƒå¤´å’Œè®­ç»ƒæ§åˆ¶ -->
            <div class="lg:col-span-2 space-y-8">
                <!-- æ‘„åƒå¤´åŒºåŸŸ -->
                <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-center" id="camera-section-title">ğŸ“· å®æ—¶åº·å¤è®­ç»ƒ</h2>
                    
                    <!-- æˆå°±æ˜¾ç¤ºåœ¨è§†é¢‘ä¸Šæ–¹ -->
                    <div class="relative">
                        <div id="achievementsOverlay" class="achievements-overlay"></div>
                        <div class="video-container" id="videoContainer">
                            <video id="webcam" playsinline style="display: none;"></video>
                            <canvas id="output_canvas" style="display: none;"></canvas>
                            <div class="video-placeholder" id="videoPlaceholder">
                                <i class="fas fa-video"></i>
                                <div id="camera-off-text">æ‘„åƒå¤´æœªå¼€å¯</div>
                                <div class="text-sm opacity-80 mt-2" id="camera-hint">ç‚¹å‡»"å¼€å¯æ‘„åƒå¤´"å¼€å§‹è®­ç»ƒ</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex flex-wrap gap-4 my-6 justify-center">
                        <button id="cameraToggle" onclick="toggleCamera()" class="btn btn-primary">
                            <i class="fas fa-camera"></i>
                            <span class="btn-text" id="camera-btn-text">å¼€å¯æ‘„åƒå¤´</span>
                        </button>
                        <button id="startTrainingBtn" onclick="toggleTraining()" disabled class="btn btn-success">
                            <i class="fas fa-play-circle"></i>
                            <span class="btn-text" id="training-btn-text">å¼€å§‹è®­ç»ƒ</span>
                        </button>
                        <button id="resetTrainingBtn" onclick="resetTraining()" class="btn btn-warning">
                            <i class="fas fa-redo"></i>
                            <span class="btn-text" id="reset-btn-text">é‡ç½®è®­ç»ƒ</span>
                        </button>
                    </div>

                    <!-- æ­¥éª¤æŒ‡ç¤ºå™¨ -->
                    <div id="stepIndicatorContainer" class="step-indicator"></div>
                </div>

                <!-- è®­ç»ƒç»Ÿè®¡ -->
                <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-center" id="stats-section-title">ğŸ“Š è®­ç»ƒç»Ÿè®¡</h2>
                    
                    <!-- æ•´ä½“è¿›åº¦æ¡ -->
                    <div class="progress-visualization">
                        <div class="flex justify-between items-center mb-2">
                            <span class="font-bold">æ•´ä½“è¿›åº¦</span>
                            <span id="progressPercentage">0%</span>
                        </div>
                        <div class="progress-container">
                            <div id="overallProgressBar" class="progress-bar" style="width: 0%"></div>
                        </div>
                        <div id="progressStats" class="text-sm mt-2"></div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                        <div class="bg-white/10 p-4 rounded-lg text-center">
                            <div class="text-sm opacity-80 mb-1" id="current-exercise-label">å½“å‰åŠ¨ä½œ</div>
                            <div class="text-xl font-bold" id="currentExercise">æœªå¼€å§‹</div>
                        </div>
                        <div class="bg-white/10 p-4 rounded-lg text-center">
                            <div class="text-sm opacity-80 mb-1" id="completed-reps-label">å®Œæˆæ¬¡æ•°</div>
                            <div class="text-xl font-bold"><span id="completedReps">0</span> / <span id="targetReps">10</span></div>
                        </div>
                        <div class="bg-white/10 p-4 rounded-lg text-center">
                            <div class="text-sm opacity-80 mb-1" id="accuracy-label">å‡†ç¡®ç‡</div>
                            <div class="text-xl font-bold" id="accuracyRate">0%</div>
                        </div>
                        <div class="bg-white/10 p-4 rounded-lg text-center">
                            <div class="text-sm opacity-80 mb-1" id="training-time-label">è®­ç»ƒæ—¶é•¿</div>
                            <div class="text-xl font-bold" id="trainingTime">00:00</div>
                        </div>
                    </div>
                </div>               

                <!-- å§¿æ€æ•°æ®å›¾è¡¨ï¼šæ”¾åœ¨å·¦ä¾§ï¼ˆä¸AIæ¨¡å‹å’Œåé¦ˆå¹¶åˆ—ï¼‰ -->
                <div class="w-full">
                    <div class="bg-white/10 rounded-2xl p-6 shadow-lg">
                        <h3 class="text-xl font-bold mb-4" id="pose-data-chart-title">å§¿æ€æ•°æ®</h3>
                        <div class="chart-container" style="height:200px; background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px;">
                            <canvas id="poseDataChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šåº·å¤è®¡åˆ’å’Œæ¨¡å‹ä¿¡æ¯ -->
            <div class="space-y-8">
                <!-- åº·å¤è®¡åˆ’ -->
                <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-center" id="plan-section-title">ğŸ“‹ åº·å¤è®¡åˆ’</h2>
                    
                    <!-- æ¶ˆæ¯æé†’åŒºåŸŸ -->
                    <div id="messageDisplay" class="mb-4"></div>

                    <!-- æ™ºèƒ½è®­ç»ƒå…¥å£ -->
                    <div class="smart-training-card" onclick="startSmartTraining()">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <i class="fas fa-robot text-2xl"></i>
                            <div>
                                <div class="font-bold" id="smart-training-title">æ™ºèƒ½è®­ç»ƒæ¨¡å¼</div>
                                <div class="text-sm" id="smart-training-subtitle">ä¸€é”®å¯åŠ¨ä¸ªæ€§åŒ–åº·å¤è®¡åˆ’</div>
                            </div>
                        </div>
                        <div class="text-sm opacity-80" id="smart-training-description">åŸºäºAIåˆ†ææ¨èæœ€é€‚åˆæ‚¨çš„è®­ç»ƒæ–¹æ¡ˆ</div>
                    </div>

                    <!-- èƒ½åŠ›åˆ†æå¡ç‰‡ - ç§»åŠ¨åˆ°æ¨¡å‹ä¸Šæ–¹ -->
                    <div class="bg-white/10 p-4 rounded-lg mb-4">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <i class="fas fa-chart-line text-2xl text-accent"></i>
                            <div>
                                <div class="font-bold" id="ability-analysis-title">èƒ½åŠ›åˆ†æ</div>
                                <div class="text-sm" id="ability-analysis-subtitle">äº†è§£æ‚¨çš„åº·å¤æ°´å¹³</div>
                            </div>
                        </div>
                        
                        <div id="abilityDisplay">
                            <div class="text-center py-4">
                                <div class="text-lg font-bold mb-2" id="current-ability-level">æœªåˆ†æ</div>
                                <div class="text-sm opacity-80" id="ability-description">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ†ææ‚¨çš„èƒ½åŠ›æ°´å¹³</div>
                            </div>
                        </div>
                        
                        <button onclick="analyzePatientAbility()" class="btn btn-secondary w-full mt-2">
                            <i class="fas fa-analytics"></i>
                            <span class="btn-text" id="analyze-ability-btn-text">åˆ†æèƒ½åŠ›æ°´å¹³</span>
                        </button>
                    </div>
                    
                    <div class="space-y-4 mt-4" id="exerciseList">
                        <!-- åº·å¤åŠ¨ä½œå°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    
                    <div class="mt-6">
                        <button onclick="showCustomizeModal()" class="btn btn-secondary w-full">
                            <i class="fas fa-cog"></i>
                            <span class="btn-text" id="customize-btn-text">ä¸ªæ€§åŒ–è®¾ç½®</span>
                        </button>
                    </div>
                </div>

                <!-- æ¨¡å‹ä¿¡æ¯ -->
                <div class="grid grid-cols-1 gap-6">
                    <div class="flex flex-col lg:flex-row gap-6">
                        <!-- AI æ¨¡å‹ ä¸ å®æ—¶åé¦ˆï¼šæ”¾åœ¨å³ä¾§å‚ç›´å †å  -->
                        <div class="w-full space-y-6">
                            <!-- AI æ¨¡å‹ -->
                            <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow">
                                <h2 class="text-2xl font-bold mb-4 text-center" id="model-section-title">ğŸ¤– AIæ¨¡å‹</h2>
                                <div class="bg-white/10 p-4 rounded-lg">
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="font-semibold" id="current-model-label">å½“å‰æ¨¡å‹:</span>
                                        <span id="currentModelName" class="text-accent">æœªåŠ è½½</span>
                                    </div>
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="font-semibold" id="accuracy-label2">å‡†ç¡®ç‡:</span>
                                        <span id="modelAccuracy">-</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <span class="font-semibold" id="status-label">çŠ¶æ€:</span>
                                        <span id="modelStatus" class="text-warning">æœªè¿æ¥</span>
                                    </div>
                                </div>
                                <div class="mt-4">
                                    <button onclick="loadPublishedModel()" class="btn btn-primary w-full">
                                        <i class="fas fa-sync-alt"></i>
                                        <span class="btn-text" id="load-model-btn-text">åŠ è½½æœ€æ–°æ¨¡å‹</span>
                                    </button>
                                </div>
                            </div>

                            <!-- å®æ—¶åé¦ˆ -->
                            <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow">
                                <h2 class="text-2xl font-bold mb-4 text-center" id="feedback-section-title">ğŸ’¬ å®æ—¶åé¦ˆ</h2>
                                <div class="bg-white/10 p-4 rounded-lg min-h-[120px]">
                                    <div id="feedbackMessage" class="text-center">
                                        <i class="fas fa-info-circle text-xl mb-2 opacity-70"></i>
                                        <div id="waiting-feedback">ç­‰å¾…è®­ç»ƒå¼€å§‹...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- è®­ç»ƒå†å²å›¾è¡¨ -->
        <div class="card-gradient rounded-2xl p-6 shadow-lg border border-accent/30 border-glow fade-in mt-8">
            <h2 class="text-2xl font-bold mb-4 text-center" id="history-section-title">ğŸ“ˆ è®­ç»ƒå†å²</h2>
            <div class="chart-container">
                <canvas id="trainingHistoryChart"></canvas>
            </div>
        </div>
    </div>

    <!-- ä¸ªæ€§åŒ–è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="customizeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="customize-modal-title">ä¸ªæ€§åŒ–åº·å¤è®¾ç½®</h2>
                <button class="close-btn" onclick="closeCustomizeModal()">&times;</button>
            </div>
            <div style="padding: 20px; color: #333;">
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2" id="patient-name-label">æ‚£è€…å§“å</label>
                    <input type="text" id="patientName" class="w-full p-2 border rounded" placeholder="è¯·è¾“å…¥æ‚£è€…å§“å">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2" id="target-reps-label">ç›®æ ‡é‡å¤æ¬¡æ•°</label>
                    <input type="number" id="customTargetReps" class="w-full p-2 border rounded" min="1" max="50" value="10">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2" id="difficulty-label">è®­ç»ƒéš¾åº¦</label>
                    <select id="trainingDifficulty" class="w-full p-2 border rounded">
                        <option value="easy">ç®€å•</option>
                        <option value="medium" selected>ä¸­ç­‰</option>
                        <option value="hard">å›°éš¾</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2" id="select-exercises-label">é€‰æ‹©åº·å¤åŠ¨ä½œ</label>
                    <div class="space-y-2">
                        <label class="flex items-center">
                            <input type="checkbox" class="mr-2" value="shoulder_flexion" checked>
                            <span id="shoulder_flexion_label">è‚©éƒ¨å±ˆæ›²</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" class="mr-2" value="shoulder_abduction" checked>
                            <span id="shoulder_abduction_label">è‚©éƒ¨å¤–å±•</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" class="mr-2" value="elbow_flexion" checked>
                            <span id="elbow_flexion_label">è‚˜éƒ¨å±ˆæ›²</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" class="mr-2" value="wrist_flexion">
                            <span id="wrist_flexion_label">è…•éƒ¨å±ˆæ›²</span>
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" class="mr-2" value="arm_rotation">
                            <span id="arm_rotation_label">æ‰‹è‡‚æ—‹è½¬</span>
                        </label>
                    </div>
                </div>
                <div class="flex justify-end mt-6">
                    <button onclick="closeCustomizeModal()" class="btn bg-gray-500 hover:bg-gray-600 text-white mr-2">
                        <i class="fas fa-times"></i>
                        <span class="btn-text" id="cancel-btn">å–æ¶ˆ</span>
                    </button>
                    <button onclick="saveCustomization()" class="btn btn-primary">
                        <i class="fas fa-save"></i>
                        <span class="btn-text" id="save-btn">ä¿å­˜è®¾ç½®</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- èƒ½åŠ›åˆ†æç»“æœæ¨¡æ€æ¡† -->
    <div class="modal" id="abilityAnalysisModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="ability-modal-title">èƒ½åŠ›åˆ†æç»“æœ</h2>
                <button class="close-btn" onclick="closeAbilityAnalysisModal()">&times;</button>
            </div>
            <div style="padding: 20px; color: #333;">
                <div id="abilityAnalysisResult">
                    <!-- åˆ†æç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
                <div class="flex justify-end mt-6">
                    <button onclick="closeAbilityAnalysisModal()" class="btn bg-gray-500 hover:bg-gray-600 text-white mr-2">
                        <i class="fas fa-times"></i>
                        <span class="btn-text" id="close-ability-btn">å…³é—­</span>
                    </button>
                    <button onclick="applyAbilityRecommendations()" class="btn btn-primary">
                        <i class="fas fa-check"></i>
                        <span class="btn-text" id="apply-recommendations-btn">åº”ç”¨å»ºè®®</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== å…¨å±€å˜é‡å£°æ˜ ==========
        let videoElement = null;
        let canvasElement = null;
        let pose = null;
        let camera = null;
        let poseDataChart = null;
        let poseChartData = [];
        let currentPoseMetricKey = 'elbow_flexion';
        let isTraining = false;
        let trainingStartTime = null;
        let trainingTimer = null;
        let currentExerciseIndex = 0;
        let completedReps = 0;
        let targetReps = 10;
        let correctPredictions = 0;
        let totalPredictions = 0;
        let publishedModel = null;
        let trainingHistoryChart = null;
        let exerciseList = [];
        let currentExercise = null;
        let voiceAssistant = null;
        let lastRepTime = 0;
        const REP_COOLDOWN = 2000;
        let restTimer = null;
        let animationFrameId = null;
        let currentLanguage = localStorage.getItem('rehab_language') || 'zh';

        // ========== æ–°å¢ç³»ç»Ÿå®ä¾‹ ==========
        let visualGuideSystem;
        let stepIndicator;
        let smartTrainingMode;
        let achievementSystem;
        let restReminderSystem;
        let enhancedFeedbackSystem;
        let progressVisualization;

        // ========== è¯­éŸ³åŠ©æ‰‹ç±» ==========
        class VoiceAssistant {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voices = [];
                this.available = false;
                
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                if (this.synth) {
                    this.available = true;
                    this.loadVoices();
                }
            }
            
            loadVoices() {
                this.voices = this.synth.getVoices();
                
                // å¦‚æœæ²¡æœ‰åŠ è½½åˆ°è¯­éŸ³ï¼Œç­‰å¾…voiceschangedäº‹ä»¶
                if (this.voices.length === 0) {
                    this.synth.onvoiceschanged = () => {
                        this.voices = this.synth.getVoices();
                    };
                }
            }
            
            speak(text, rate = 1.0, pitch = 1.0) {
                if (!this.available) {
                    console.log('è¯­éŸ³åˆæˆä¸å¯ç”¨:', text);
                    return;
                }
                
                // åœæ­¢å½“å‰è¯­éŸ³
                this.synth.cancel();
                
                // åˆ›å»ºè¯­éŸ³å®ä¾‹
                const utterance = new SpeechSynthesisUtterance(text);
                
                // è®¾ç½®è¯­éŸ³å‚æ•°
                utterance.rate = rate;
                utterance.pitch = pitch;
                
                // é€‰æ‹©ä¸­æ–‡è¯­éŸ³ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                const chineseVoice = this.voices.find(voice => 
                    voice.lang.includes('zh') || voice.lang.includes('CN')
                );
                
                if (chineseVoice && currentLanguage === 'zh') {
                    utterance.voice = chineseVoice;
                }
                
                // æ’­æ”¾è¯­éŸ³
                this.synth.speak(utterance);
            }
            
            // è®­ç»ƒç›¸å…³è¯­éŸ³æç¤º
            trainingStart() {
                this.speak(currentLanguage === 'zh' ? 
                    'è®­ç»ƒå¼€å§‹ï¼Œè¯·æŒ‰ç…§ç¤ºèŒƒå®ŒæˆåŠ¨ä½œ' : 
                    'Training started, please follow the demonstration to complete the exercises');
            }
            
            exerciseComplete(count, total) {
                this.speak(currentLanguage === 'zh' ? 
                    `å¾ˆå¥½ï¼å·²å®Œæˆ ${count} æ¬¡ï¼Œç›®æ ‡ ${total} æ¬¡` : 
                    `Great! Completed ${count} times, target ${total} times`);
            }
            
            trainingComplete() {
                this.speak(currentLanguage === 'zh' ? 
                    'æ­å–œï¼è®­ç»ƒå®Œæˆï¼Œä¼‘æ¯ä¸€ä¸‹å§' : 
                    'Congratulations! Training completed, take a rest');
            }
            
            correctionNeeded() {
                this.speak(currentLanguage === 'zh' ? 
                    'åŠ¨ä½œéœ€è¦è°ƒæ•´ï¼Œè¯·å‚è€ƒç¤ºèŒƒ' : 
                    'Action needs adjustment, please refer to the demonstration');
            }
            
            restReminder() {
                this.speak(currentLanguage === 'zh' ? 
                    'å·²ç»è®­ç»ƒäº†ä¸€æ®µæ—¶é—´äº†ï¼Œå»ºè®®ä¼‘æ¯ä¸€ä¸‹' : 
                    'You have been training for a while, it is recommended to take a break');
            }
        }

        // ========== å¤šè¯­è¨€æ”¯æŒ ==========
        const i18n = {
            en: {
                // é¡µé¢æ ‡é¢˜å’Œå‰¯æ ‡é¢˜
                pageTitle: 'Upper Limb Rehabilitation Training System',
                pageSubtitle: 'AI-based Upper Limb Rehabilitation Training and Assessment Platform',
                
                // è¯­è¨€åˆ‡æ¢æŒ‰é’®
                langText: 'ä¸­æ–‡',
                
                // å„éƒ¨åˆ†æ ‡é¢˜
                cameraSectionTitle: 'ğŸ“· Real-time Rehabilitation Training',
                statsSectionTitle: 'ğŸ“Š Training Statistics',
                planSectionTitle: 'ğŸ“‹ Rehabilitation Plan',
                modelSectionTitle: 'ğŸ¤– AI Model',
                feedbackSectionTitle: 'ğŸ’¬ Real-time Feedback',
                historySectionTitle: 'ğŸ“ˆ Training History',
                poseDataChartTitle: 'Pose Data',
                
                // æ‘„åƒå¤´åŒºåŸŸ
                cameraOffText: 'Camera Off',
                cameraHint: 'Click "Start Camera" to begin training',
                cameraBtnText: 'Start Camera',
                trainingBtnText: 'Start Training',
                resetBtnText: 'Reset Training',
                
                // è®­ç»ƒç»Ÿè®¡
                currentExerciseLabel: 'Current Exercise',
                completedRepsLabel: 'Completed Reps',
                accuracyLabel: 'Accuracy',
                trainingTimeLabel: 'Training Time',
                
                // æ¨¡å‹ä¿¡æ¯
                currentModelLabel: 'Current Model:',
                accuracyLabel2: 'Accuracy:',
                statusLabel: 'Status:',
                loadModelBtnText: 'Load Latest Model',
                
                // åº·å¤è®¡åˆ’
                customizeBtnText: 'Customize Settings',
                
                // å®æ—¶åé¦ˆ
                waitingFeedback: 'Waiting for training to start...',
                
                // æ¨¡æ€æ¡†
                customizeModalTitle: 'Personalized Rehabilitation Settings',
                patientNameLabel: 'Patient Name',
                targetRepsLabel: 'Target Repetitions',
                difficultyLabel: 'Training Difficulty',
                selectExercisesLabel: 'Select Rehabilitation Exercises',
                cancelBtn: 'Cancel',
                saveBtn: 'Save Settings',
                
                // åº·å¤åŠ¨ä½œåç§°
                shoulder_flexion: 'Shoulder Flexion',
                shoulder_abduction: 'Shoulder Abduction',
                elbow_flexion: 'Elbow Flexion',
                wrist_flexion: 'Wrist Flexion',
                arm_rotation: 'Arm Rotation',
                
                // éš¾åº¦çº§åˆ«
                easy: 'Easy',
                medium: 'Medium',
                hard: 'Hard',
                
                // è®­ç»ƒçŠ¶æ€
                notStarted: 'Not Started',
                notConnected: 'Not Connected',
                loaded: 'Loaded',
                
                // ä¸´æ—¶æ¶ˆæ¯
                cameraStarted: 'Camera started successfully',
                cameraStopped: 'Camera stopped',
                trainingStarted: 'Training started!',
                trainingStopped: 'Training stopped!',
                trainingReset: 'Training data reset',
                modelLoaded: 'Model loaded successfully',
                customizationSaved: 'Customization saved successfully',
                noModelFound: 'No published model found, please publish a model in the training page first',
                noExerciseSelected: 'Please select an exercise first',
                noCameraStarted: 'Please start the camera first',
                mediapipeError: 'MediaPipe initialization failed, please refresh the page and try again',
                cameraPermissionError: 'Camera permission denied, please allow camera access',
                cameraNotFoundError: 'No camera device found',
                cameraNotSupportedError: 'Browser does not support camera function',
                cameraParameterError: 'Cannot satisfy camera parameter requirements',
                cameraGeneralError: 'Unable to start camera',
                
                // åé¦ˆæ¶ˆæ¯
                selectExerciseFeedback: 'Please select an exercise to start training',
                trainingStoppedFeedback: 'Training stopped',
                trainingResetFeedback: 'Training reset, please select an exercise to start new training',
                allExercisesCompleted: 'Congratulations! You have completed all rehabilitation exercises!',
                planCompleted: 'Rehabilitation plan completed!',
                startExerciseFeedback: 'Starting {exercise} training, please follow the instructions to complete the exercises',
                exerciseProgressFeedback: 'Great! Completed {completed}/{target} exercises',
                exerciseCompletedFeedback: 'Congratulations! Completed all {target} exercises',
                adjustmentNeededFeedback: 'Action needs adjustment, please refer to the demonstration',
                
                // å›¾è¡¨æ ‡ç­¾
                accuracyChartLabel: 'Accuracy (%)',
                repsChartLabel: 'Completed Reps',
                trainingHistoryTitle: 'Training History Trend',
                trainingDateLabel: 'Training Date',
                
                // èƒ½åŠ›åˆ†æç›¸å…³
                'ability-analysis-title': 'Ability Analysis',
                'ability-analysis-subtitle': 'Understand Your Rehabilitation Level',
                'analyze-ability-btn-text': 'Analyze Ability Level',
                'ability-modal-title': 'Ability Analysis Results',
                'close-ability-btn': 'Close',
                'apply-recommendations-btn': 'Apply Recommendations',
                
                // æ™ºèƒ½è®­ç»ƒç›¸å…³
                'smart-training-title': 'Smart Training Mode',
                'smart-training-subtitle': 'One-click personalized rehabilitation plan',
                'smart-training-description': 'Based on AI analysis to recommend the most suitable training plan for you'
            },
            zh: {
                // é¡µé¢æ ‡é¢˜å’Œå‰¯æ ‡é¢˜
                pageTitle: 'ä¸Šè‚¢åº·å¤è®­ç»ƒç³»ç»Ÿ',
                pageSubtitle: 'åŸºäºAIæ¨¡å‹çš„ä¸Šè‚¢åº·å¤è®­ç»ƒä¸è¯„ä¼°å¹³å°',
                
                // è¯­è¨€åˆ‡æ¢æŒ‰é’®
                langText: 'English',
                
                // å„éƒ¨åˆ†æ ‡é¢˜
                cameraSectionTitle: 'ğŸ“· å®æ—¶åº·å¤è®­ç»ƒ',
                statsSectionTitle: 'ğŸ“Š è®­ç»ƒç»Ÿè®¡',
                planSectionTitle: 'ğŸ“‹ åº·å¤è®¡åˆ’',
                modelSectionTitle: 'ğŸ¤– AIæ¨¡å‹',
                feedbackSectionTitle: 'ğŸ’¬ å®æ—¶åé¦ˆ',
                historySectionTitle: 'ğŸ“ˆ è®­ç»ƒå†å²',
                poseDataChartTitle: 'å§¿æ€æ•°æ®',
                
                // æ‘„åƒå¤´åŒºåŸŸ
                cameraOffText: 'æ‘„åƒå¤´æœªå¼€å¯',
                cameraHint: 'ç‚¹å‡»"å¼€å¯æ‘„åƒå¤´"å¼€å§‹è®­ç»ƒ',
                cameraBtnText: 'å¼€å¯æ‘„åƒå¤´',
                trainingBtnText: 'å¼€å§‹è®­ç»ƒ',
                resetBtnText: 'é‡ç½®è®­ç»ƒ',
                
                // è®­ç»ƒç»Ÿè®¡
                currentExerciseLabel: 'å½“å‰åŠ¨ä½œ',
                completedRepsLabel: 'å®Œæˆæ¬¡æ•°',
                accuracyLabel: 'å‡†ç¡®ç‡',
                trainingTimeLabel: 'è®­ç»ƒæ—¶é•¿',
                
                // æ¨¡å‹ä¿¡æ¯
                currentModelLabel: 'å½“å‰æ¨¡å‹:',
                accuracyLabel2: 'å‡†ç¡®ç‡:',
                statusLabel: 'çŠ¶æ€:',
                loadModelBtnText: 'åŠ è½½æœ€æ–°æ¨¡å‹',
                
                // åº·å¤è®¡åˆ’
                customizeBtnText: 'ä¸ªæ€§åŒ–è®¾ç½®',
                
                // å®æ—¶åé¦ˆ
                waitingFeedback: 'ç­‰å¾…è®­ç»ƒå¼€å§‹...',
                
                // æ¨¡æ€æ¡†
                customizeModalTitle: 'ä¸ªæ€§åŒ–åº·å¤è®¾ç½®',
                patientNameLabel: 'æ‚£è€…å§“å',
                targetRepsLabel: 'ç›®æ ‡é‡å¤æ¬¡æ•°',
                difficultyLabel: 'è®­ç»ƒéš¾åº¦',
                selectExercisesLabel: 'é€‰æ‹©åº·å¤åŠ¨ä½œ',
                cancelBtn: 'å–æ¶ˆ',
                saveBtn: 'ä¿å­˜è®¾ç½®',
                
                // åº·å¤åŠ¨ä½œåç§°
                shoulder_flexion: 'è‚©éƒ¨å±ˆæ›²',
                shoulder_abduction: 'è‚©éƒ¨å¤–å±•',
                elbow_flexion: 'è‚˜éƒ¨å±ˆæ›²',
                wrist_flexion: 'è…•éƒ¨å±ˆæ›²',
                arm_rotation: 'æ‰‹è‡‚æ—‹è½¬',
                
                // éš¾åº¦çº§åˆ«
                easy: 'ç®€å•',
                medium: 'ä¸­ç­‰',
                hard: 'å›°éš¾',
                
                // è®­ç»ƒçŠ¶æ€
                notStarted: 'æœªå¼€å§‹',
                notConnected: 'æœªè¿æ¥',
                loaded: 'å·²åŠ è½½',
                
                // ä¸´æ—¶æ¶ˆæ¯
                cameraStarted: 'æ‘„åƒå¤´å·²å¼€å¯',
                cameraStopped: 'æ‘„åƒå¤´å·²å…³é—­',
                trainingStarted: 'è®­ç»ƒå¼€å§‹ï¼',
                trainingStopped: 'è®­ç»ƒç»“æŸï¼',
                trainingReset: 'è®­ç»ƒæ•°æ®å·²é‡ç½®',
                modelLoaded: 'æ¨¡å‹å·²åŠ è½½',
                customizationSaved: 'ä¸ªæ€§åŒ–è®¾ç½®å·²ä¿å­˜',
                noModelFound: 'æœªæ‰¾åˆ°å·²å‘å¸ƒçš„æ¨¡å‹ï¼Œè¯·å…ˆåœ¨æ¨¡å‹è®­ç»ƒé¡µé¢å‘å¸ƒæ¨¡å‹',
                noExerciseSelected: 'è¯·å…ˆé€‰æ‹©åº·å¤åŠ¨ä½œ',
                noCameraStarted: 'è¯·å…ˆå¼€å¯æ‘„åƒå¤´',
                mediapipeError: 'MediaPipeåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•',
                cameraPermissionError: 'æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼Œè¯·å…è®¸æ‘„åƒå¤´è®¿é—®',
                cameraNotFoundError: 'æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡',
                cameraNotSupportedError: 'æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´åŠŸèƒ½',
                cameraParameterError: 'æ— æ³•æ»¡è¶³æ‘„åƒå¤´å‚æ•°è¦æ±‚',
                cameraGeneralError: 'æ— æ³•å¯åŠ¨æ‘„åƒå¤´',
                
                // åé¦ˆæ¶ˆæ¯
                selectExerciseFeedback: 'è¯·é€‰æ‹©åº·å¤åŠ¨ä½œå¼€å§‹è®­ç»ƒ',
                trainingStoppedFeedback: 'è®­ç»ƒå·²åœæ­¢',
                trainingResetFeedback: 'è®­ç»ƒå·²é‡ç½®ï¼Œè¯·é€‰æ‹©åŠ¨ä½œå¼€å§‹æ–°çš„è®­ç»ƒ',
                allExercisesCompleted: 'æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰åº·å¤åŠ¨ä½œï¼',
                planCompleted: 'åº·å¤è®¡åˆ’å®Œæˆï¼',
                startExerciseFeedback: 'å¼€å§‹è¿›è¡Œ{exercise}è®­ç»ƒï¼Œè¯·æŒ‰ç…§è¯´æ˜å®ŒæˆåŠ¨ä½œ',
                exerciseProgressFeedback: 'å¾ˆå¥½ï¼å·²å®Œæˆ {completed}/{target} æ¬¡åŠ¨ä½œ',
                exerciseCompletedFeedback: 'æ­å–œï¼å·²å®Œæˆæ‰€æœ‰ {target} æ¬¡åŠ¨ä½œ',
                adjustmentNeededFeedback: 'åŠ¨ä½œéœ€è¦è°ƒæ•´ï¼Œè¯·å‚è€ƒç¤ºèŒƒåŠ¨ä½œ',
                
                // å›¾è¡¨æ ‡ç­¾
                accuracyChartLabel: 'å‡†ç¡®ç‡ (%)',
                repsChartLabel: 'å®Œæˆæ¬¡æ•°',
                trainingHistoryTitle: 'è®­ç»ƒå†å²è¶‹åŠ¿',
                trainingDateLabel: 'è®­ç»ƒæ—¥æœŸ',
                
                // èƒ½åŠ›åˆ†æç›¸å…³
                'ability-analysis-title': 'èƒ½åŠ›åˆ†æ',
                'ability-analysis-subtitle': 'äº†è§£æ‚¨çš„åº·å¤æ°´å¹³',
                'analyze-ability-btn-text': 'åˆ†æèƒ½åŠ›æ°´å¹³',
                'ability-modal-title': 'èƒ½åŠ›åˆ†æç»“æœ',
                'close-ability-btn': 'å…³é—­',
                'apply-recommendations-btn': 'åº”ç”¨å»ºè®®',
                
                // æ™ºèƒ½è®­ç»ƒç›¸å…³
                'smart-training-title': 'æ™ºèƒ½è®­ç»ƒæ¨¡å¼',
                'smart-training-subtitle': 'ä¸€é”®å¯åŠ¨ä¸ªæ€§åŒ–åº·å¤è®¡åˆ’',
                'smart-training-description': 'åŸºäºAIåˆ†ææ¨èæœ€é€‚åˆæ‚¨çš„è®­ç»ƒæ–¹æ¡ˆ'
            }
        };

        // ========== åº·å¤åŠ¨ä½œé…ç½® ==========
        const exercises = {
            'shoulder_flexion': {
                name: {
                    en: 'Shoulder Flexion',
                    zh: 'è‚©éƒ¨å±ˆæ›²'
                },
                description: {
                    en: 'Slowly lift your arm forward and upward',
                    zh: 'ç¼“æ…¢æŠ¬èµ·æ‰‹è‡‚å‘å‰ä¸Šæ–¹ä¼¸å±•'
                },
                difficulty: 'medium',
                targetMuscles: {
                    en: ['Deltoid', 'Biceps'],
                    zh: ['ä¸‰è§’è‚Œ', 'è‚±äºŒå¤´è‚Œ']
                }
            },
            'shoulder_abduction': {
                name: {
                    en: 'Shoulder Abduction',
                    zh: 'è‚©éƒ¨å¤–å±•'
                },
                description: {
                    en: 'Lift your arms sideways away from your body',
                    zh: 'æ‰‹è‡‚å‘èº«ä½“ä¸¤ä¾§å¹³ä¸¾'
                },
                difficulty: 'medium',
                targetMuscles: {
                    en: ['Deltoid', 'Supraspinatus'],
                    zh: ['ä¸‰è§’è‚Œ', 'å†ˆä¸Šè‚Œ']
                }
            },
            'elbow_flexion': {
                name: {
                    en: 'Elbow Flexion',
                    zh: 'è‚˜éƒ¨å±ˆæ›²'
                },
                description: {
                    en: 'Bend your elbow to bring your forearm closer to your upper arm',
                    zh: 'å¼¯æ›²è‚˜å…³èŠ‚ä½¿å‰è‡‚é è¿‘ä¸Šè‡‚'
                },
                difficulty: 'easy',
                targetMuscles: {
                    en: ['Biceps', 'Brachialis'],
                    zh: ['è‚±äºŒå¤´è‚Œ', 'è‚±è‚Œ']
                }
            },
            'wrist_flexion': {
                name: {
                    en: 'Wrist Flexion',
                    zh: 'è…•éƒ¨å±ˆæ›²'
                },
                description: {
                    en: 'Slowly bend your wrist',
                    zh: 'ç¼“æ…¢å¼¯æ›²æ‰‹è…•'
                },
                difficulty: 'easy',
                targetMuscles: {
                    en: ['Wrist Flexors'],
                    zh: ['è…•å±ˆè‚Œ']
                }
            },
            'arm_rotation': {
                name: {
                    en: 'Arm Rotation',
                    zh: 'æ‰‹è‡‚æ—‹è½¬'
                },
                description: {
                    en: 'Internal and external rotation of the arm',
                    zh: 'æ‰‹è‡‚å†…å¤–æ—‹è½¬è¿åŠ¨'
                },
                difficulty: 'hard',
                targetMuscles: {
                    en: ['Rotator Cuff'],
                    zh: ['è‚©è¢–è‚Œç¾¤']
                }
            }
        };

        // ========== è®­ç»ƒå†å²æ•°æ® ==========
        let trainingHistory = {
            dates: [],
            accuracy: [],
            completedReps: [],
            duration: []
        };

        // ========== è§†è§‰å¼•å¯¼ç³»ç»Ÿ ==========
        class VisualGuideSystem {
            constructor() {
                this.currentGuide = null;
                this.targetPose = null;
            }
            
            showTargetPose(exerciseType) {
                this.clearGuides();
                
                const canvas = document.getElementById('output_canvas');
                if (!canvas) return;
                
                this.targetPose = document.createElement('div');
                this.targetPose.className = 'target-pose-indicator';
                
                // æ ¹æ®åŠ¨ä½œç±»å‹æ˜¾ç¤ºä¸åŒçš„ç›®æ ‡å§¿åŠ¿æŒ‡ç¤º
                const guide = this.createExerciseGuide(exerciseType);
                if (guide) {
                    this.targetPose.appendChild(guide);
                    canvas.parentElement.appendChild(this.targetPose);
                }
            }
            
            createExerciseGuide(exerciseType) {
                const guide = document.createElement('div');
                guide.className = 'visual-guide';
                
                switch(exerciseType) {
                    case 'shoulder_flexion':
                        guide.style.cssText = 'width: 200px; height: 300px; top: 20%; left: 50%; transform: translateX(-50%);';
                        guide.innerHTML = '<div style="text-align: center; color: #4facfe; font-weight: bold;">ç›®æ ‡å§¿åŠ¿: æ‰‹è‡‚å‰ä¸¾</div>';
                        break;
                    case 'elbow_flexion':
                        guide.style.cssText = 'width: 150px; height: 200px; top: 30%; left: 60%;';
                        guide.innerHTML = '<div style="text-align: center; color: #4facfe; font-weight: bold;">ç›®æ ‡å§¿åŠ¿: è‚˜éƒ¨å¼¯æ›²</div>';
                        break;
                    case 'shoulder_abduction':
                        guide.style.cssText = 'width: 300px; height: 200px; top: 25%; left: 50%; transform: translateX(-50%);';
                        guide.innerHTML = '<div style="text-align: center; color: #4facfe; font-weight: bold;">ç›®æ ‡å§¿åŠ¿: æ‰‹è‡‚ä¾§å¹³ä¸¾</div>';
                        break;
                }
                
                return guide;
            }
            
            clearGuides() {
                if (this.targetPose) {
                    this.targetPose.remove();
                    this.targetPose = null;
                }
            }
        }

        // ========== æ­¥éª¤æŒ‡ç¤ºå™¨ ==========
        class StepIndicator {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.steps = [];
                this.currentStep = 0;
            }
            
            setSteps(steps) {
                this.steps = steps;
                this.render();
            }
            
            render() {
                if (!this.container) return;
                
                this.container.innerHTML = '';
                this.steps.forEach((step, index) => {
                    const dot = document.createElement('div');
                    dot.className = `step-dot ${index === this.currentStep ? 'active' : ''} ${index < this.currentStep ? 'completed' : ''}`;
                    dot.title = step;
                    this.container.appendChild(dot);
                });
            }
            
            nextStep() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.render();
                }
            }
            
            reset() {
                this.currentStep = 0;
                this.render();
            }
        }

        // ========== æ™ºèƒ½è®­ç»ƒæ¨¡å¼ ==========
        class SmartTrainingMode {
            constructor() {
                this.isActive = false;
                this.currentPlan = null;
                this.backendAvailable = true; // é»˜è®¤è®¤ä¸ºåç«¯å¯ç”¨
            }
            
            async startSmartTraining(patientId = 'default_patient') {
                // å¦‚æœåç«¯ä¸å¯ç”¨ï¼Œç›´æ¥ä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
                if (!this.backendAvailable) {
                    this.useFallbackTrainingPlan();
                    return true;
                }
                
                try {
                    console.log('å¼€å§‹æ™ºèƒ½è®­ç»ƒï¼Œæ‚£è€…ID:', patientId);
                    
                    const response = await fetch(API_BASE_URL+'/generate_training_plan', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            patient_id: patientId,
                            category: 'upper_limb',
                            ability_level: 'intermediate' // å¯æ ¹æ®å®é™…æƒ…å†µåŠ¨æ€è·å–
                        })
                    });
                    
                    console.log('å“åº”çŠ¶æ€:', response.status);
                    
                    if (!response.ok) {
                        // å¦‚æœåç«¯è¿”å›é”™è¯¯ï¼Œæ ‡è®°ä¸ºä¸å¯ç”¨å¹¶ä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
                        this.backendAvailable = false;
                        this.useFallbackTrainingPlan();
                        return true;
                    }
                    
                    const data = await response.json();
                    console.log('å“åº”æ•°æ®:', data);
                    
                    if (data.status === 'success') {
                        this.currentPlan = data.training_plan;
                        this.isActive = true;
                        this.applyTrainingPlan(this.currentPlan);
                        return true;
                    } else {
                        throw new Error(data.error || 'Unknown error from backend');
                    }
                    
                } catch (error) {
                    console.error('æ™ºèƒ½è®­ç»ƒå¯åŠ¨å¤±è´¥:', error);
                    
                    // ç½‘ç»œé”™è¯¯æ—¶ä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
                    this.backendAvailable = false;
                    this.useFallbackTrainingPlan();
                    return true;
                }
            }
            
            useFallbackTrainingPlan() {
                // ä½¿ç”¨é»˜è®¤çš„è®­ç»ƒè®¡åˆ’
                const fallbackPlan = {
                    patient_id: 'default_patient',
                    category: 'upper_limb',
                    ability_level: 'intermediate',
                    training_plan: {
                        recommended_exercises: ["shoulder_flexion", "elbow_flexion", "shoulder_abduction"],
                        target_reps: 12,
                        sets: 3,
                        difficulty: "medium",
                        rest_intervals: 45,
                        session_duration: 20,
                        weekly_sessions: 4,
                        focus_areas: ["movement_quality", "strength_building"],
                        progress_goals: {
                            short_term: "è¾¾åˆ°12æ¬¡æ ‡å‡†é‡å¤",
                            medium_term: "æå‡åŠ¨ä½œå‡†ç¡®ç‡è‡³85%",
                            long_term: "å®Œæˆå®Œæ•´åº·å¤è®¡åˆ’"
                        }
                    },
                    ability_analysis: {
                        ability_level: "intermediate",
                        confidence: 0.75,
                        recommendations: [
                            "increase_repetition_gradually",
                            "focus_on_movement_quality",
                            "try_different_exercise_variations"
                        ],
                        estimated_recovery_weeks: 6,
                        performance_metrics: {
                            average_accuracy: 0.75,
                            total_sessions: 5,
                            best_streak: 8,
                            consistency: 0.7
                        }
                    },
                    generated_date: new Date().toISOString()
                };
                
                this.currentPlan = fallbackPlan;
                this.isActive = true;
                this.applyTrainingPlan(fallbackPlan);
                
                showTemporaryMessage(
                    currentLanguage === 'zh' ? 
                    'ä½¿ç”¨æ™ºèƒ½è®­ç»ƒè®¡åˆ’ï¼ˆæ¨¡æ‹Ÿæ•°æ®ï¼‰' : 
                    'Using smart training plan (simulated data)',
                    'info'
                );
            }
            
            applyTrainingPlan(plan) {
                const trainingPlan = plan.training_plan;
                
                // æ›´æ–°è®­ç»ƒè®¡åˆ’
                updateExercisePlan(
                    trainingPlan.recommended_exercises,
                    trainingPlan.target_reps,
                    trainingPlan.difficulty
                );
                
                // æ˜¾ç¤ºè®¡åˆ’ä¿¡æ¯
                this.showPlanOverview(plan);
            }
            
            showPlanOverview(plan) {
                const feedbackElement = document.getElementById('feedbackMessage');
                if (feedbackElement) {
                    const abilityText = currentLanguage === 'zh' ? 
                        `èƒ½åŠ›ç­‰çº§: ${this.getAbilityLevelText(plan.ability_level)}` :
                        `Ability Level: ${plan.ability_level}`;
                        
                    const exercisesText = currentLanguage === 'zh' ?
                        `æ¨èåŠ¨ä½œ: ${plan.training_plan.recommended_exercises.length}ä¸ª` :
                        `Recommended Exercises: ${plan.training_plan.recommended_exercises.length}`;
                        
                    const repsText = currentLanguage === 'zh' ?
                        `ç›®æ ‡æ¬¡æ•°: ${plan.training_plan.target_reps}æ¬¡/ç»„` :
                        `Target Reps: ${plan.training_plan.target_reps} per set`;
                    
                    feedbackElement.innerHTML = `
                        <div style="text-align: center;">
                            <i class="fas fa-robot text-2xl mb-2 text-accent"></i>
                            <div class="font-bold">${currentLanguage === 'zh' ? 'æ™ºèƒ½è®­ç»ƒè®¡åˆ’å·²å¯åŠ¨' : 'Smart Training Plan Started'}</div>
                            <div class="text-sm mt-2">${abilityText}</div>
                            <div class="text-sm">${exercisesText}</div>
                            <div class="text-sm">${repsText}</div>
                        </div>
                    `;
                }
            }
            
            getAbilityLevelText(level) {
                const levels = {
                    'beginner': 'åˆçº§',
                    'intermediate': 'ä¸­çº§', 
                    'advanced': 'é«˜çº§'
                };
                return levels[level] || level;
            }
        }

        // ========== æˆå°±ç³»ç»Ÿ ==========
        class AchievementSystem {
            constructor() {
                this.unlockedAchievements = new Set();
                this.loadAchievements();
            }
            
            loadAchievements() {
                const saved = localStorage.getItem('rehab_achievements');
                if (saved) {
                    this.unlockedAchievements = new Set(JSON.parse(saved));
                }
            }
            
            saveAchievements() {
                localStorage.setItem('rehab_achievements', JSON.stringify([...this.unlockedAchievements]));
            }
            
            async checkAndUnlock(sessionData) {
                try {
                    // æ„å»ºç®€åŒ–çš„è¯·æ±‚ä½“ï¼ŒåªåŒ…å«å¿…éœ€çš„å­—æ®µ
                    const requestBody = {
                        patient_id: 'default_patient',
                        category: 'upper_limb',
                        // ç›´æ¥åŒ…å«session_dataä¸­çš„å­—æ®µï¼Œè€Œä¸æ˜¯åµŒå¥—å¯¹è±¡
                        session_count: sessionData.session_count || 0,
                        current_streak: sessionData.current_streak || 0,
                        accuracy: sessionData.accuracy || 0,
                        total_reps: sessionData.total_reps || 0,
                        weekly_sessions: sessionData.weekly_sessions || 0
                    };

                    console.log('å‘é€æˆå°±æ£€æŸ¥è¯·æ±‚:', requestBody);

                    const response = await fetch(API_BASE_URL+'/check_achievements', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        // å¦‚æœå“åº”ä¸æ˜¯200-299ï¼ŒæŠ›å‡ºé”™è¯¯
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, response: ${errorText}`);
                    }

                    const data = await response.json();
                    console.log('æˆå°±æ£€æŸ¥å“åº”:', data);

                    if (data.status === 'success') {
                        this.unlockAchievements(data.unlocked_achievements || []);
                    } else {
                        throw new Error(data.error || 'Unknown error from server');
                    }
                } catch (error) {
                    console.error('æˆå°±æ£€æŸ¥å¤±è´¥:', error);
                    // ä½¿ç”¨æ¨¡æ‹Ÿæˆå°±æ•°æ®ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                    this.useFallbackAchievements(sessionData);
                }
            }
            
            useFallbackAchievements(sessionData) {
                const mockAchievements = [];
                
                // æ ¹æ®sessionDataæ¨¡æ‹Ÿè§£é”æˆå°±
                if (sessionData.session_count === 1) {
                    mockAchievements.push({ name: "åˆæ¬¡è®­ç»ƒ", description: "å®Œæˆç¬¬ä¸€æ¬¡åº·å¤è®­ç»ƒ", icon: "ğŸ¯" });
                }
                
                if (sessionData.current_streak >= 5) {
                    mockAchievements.push({ name: "åšæŒä¹‹æ˜Ÿ", description: "è¿ç»­è®­ç»ƒ5å¤©", icon: "ğŸ”¥" });
                }
                
                if (sessionData.accuracy >= 0.9) {
                    mockAchievements.push({ name: "ç²¾å‡†å¤§å¸ˆ", description: "å•æ¬¡è®­ç»ƒå‡†ç¡®ç‡è¾¾åˆ°90%", icon: "ğŸ¯" });
                }
                
                if (sessionData.total_reps >= 100) {
                    mockAchievements.push({ name: "æ¬¡æ•°å† å†›", description: "å•æ—¥å®Œæˆ100æ¬¡æ ‡å‡†åŠ¨ä½œ", icon: "ğŸ’ª" });
                }
                
                if (sessionData.weekly_sessions >= 5) {
                    mockAchievements.push({ name: "å‘¨æˆ˜å£«", description: "ä¸€å‘¨å®Œæˆ5æ¬¡è®­ç»ƒ", icon: "â­" });
                }
                
                this.unlockAchievements(mockAchievements);
            }
            
            unlockAchievements(achievements) {
                let newAchievements = [];
                
                achievements.forEach(achievement => {
                    if (!this.unlockedAchievements.has(achievement.name)) {
                        this.unlockedAchievements.add(achievement.name);
                        newAchievements.push(achievement);
                        this.showAchievementNotification(achievement);
                    }
                });
                
                if (newAchievements.length > 0) {
                    this.saveAchievements();
                    this.updateAchievementDisplay();
                }
            }
            
            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.className = 'temp-message success';
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">${achievement.icon}</span>
                        <div>
                            <div class="font-bold">æˆå°±è§£é”!</div>
                            <div>${achievement.name}</div>
                            <div style="font-size: 12px;">${achievement.description}</div>
                        </div>
                    </div>
                `;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
            
            updateAchievementDisplay() {
                const container = document.getElementById('achievementsOverlay');
                if (!container) return;
                
                container.innerHTML = '';
                
                this.unlockedAchievements.forEach(achievementName => {
                    const badge = document.createElement('div');
                    badge.className = 'achievement-badge';
                    badge.innerHTML = `<span>${this.getAchievementIcon(achievementName)}</span> ${achievementName}`;
                    container.appendChild(badge);
                });
            }

            getAchievementIcon(achievementName) {
                const icons = {
                    "åˆæ¬¡è®­ç»ƒ": "ğŸ¯",
                    "åšæŒä¹‹æ˜Ÿ": "ğŸ”¥",
                    "ç²¾å‡†å¤§å¸ˆ": "ğŸ¯",
                    "æ¬¡æ•°å† å†›": "ğŸ’ª",
                    "å‘¨æˆ˜å£«": "â­"
                };
                return icons[achievementName] || "ğŸ†";
            }
        }

        // ========== ä¼‘æ¯æé†’ç³»ç»Ÿ ==========
        class RestReminderSystem {
            constructor() {
                this.trainingStartTime = null;
                this.reminderShown = false;
                this.reminderInterval = null;
            }
            
            startMonitoring() {
                this.trainingStartTime = new Date();
                this.reminderShown = false;
                
                this.reminderInterval = setInterval(() => {
                    this.checkRestNeeded();
                }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            }
            
            stopMonitoring() {
                if (this.reminderInterval) {
                    clearInterval(this.reminderInterval);
                    this.reminderInterval = null;
                }
                this.hideRestReminder();
            }
            
            checkRestNeeded() {
                if (!this.trainingStartTime) return;
                
                const trainingTime = (new Date() - this.trainingStartTime) / 1000 / 60; // åˆ†é’Ÿ
                const repsCompleted = completedReps;
                
                // è®­ç»ƒæ—¶é—´è¶…è¿‡15åˆ†é’Ÿæˆ–å®Œæˆ50æ¬¡åŠ¨ä½œåæé†’ä¼‘æ¯
                if ((trainingTime > 15 || repsCompleted > 50) && !this.reminderShown) {
                    this.showRestReminder();
                    this.reminderShown = true;
                }
            }
            
            showRestReminder() {
                const messageDisplay = document.getElementById('messageDisplay');
                if (!messageDisplay) return;
                
                messageDisplay.innerHTML = `
                    <div class="rest-reminder">
                        <i class="fas fa-coffee text-xl mb-2"></i>
                        <div class="font-bold">${currentLanguage === 'zh' ? 'å»ºè®®ä¼‘æ¯' : 'Rest Recommended'}</div>
                        <div class="text-sm">${currentLanguage === 'zh' ? 'æ‚¨å·²ç»è®­ç»ƒäº†ä¸€æ®µæ—¶é—´ï¼Œå»ºè®®ä¼‘æ¯5åˆ†é’Ÿ' : 'You have been training for a while, it is recommended to take a 5-minute break'}</div>
                        <button onclick="this.parentElement.remove()" class="mt-2 px-4 py-1 bg-white text-orange-500 rounded text-sm">
                            ${currentLanguage === 'zh' ? 'çŸ¥é“äº†' : 'Got it'}
                        </button>
                    </div>
                `;
                
                // è¯­éŸ³æé†’
                if (voiceAssistant) {
                    voiceAssistant.speak(currentLanguage === 'zh' ? 
                        'æ‚¨å·²ç»è®­ç»ƒäº†ä¸€æ®µæ—¶é—´ï¼Œå»ºè®®ä¼‘æ¯5åˆ†é’Ÿ' : 
                        'You have been training for a while, it is recommended to take a 5-minute break');
                }
            }
            
            hideRestReminder() {
                const messageDisplay = document.getElementById('messageDisplay');
                if (messageDisplay) {
                    messageDisplay.innerHTML = '';
                }
            }
        }

        // ========== å¢å¼ºåé¦ˆç³»ç»Ÿ ==========
        class EnhancedFeedbackSystem {
            constructor() {
                this.technicalTips = {
                    'shoulder_flexion': [
                        'è‚©è†€æ”¾æ¾ï¼Œä¸è¦è€¸è‚©',
                        'æ‰‹è‡‚æŠ¬èµ·æ—¶è‚˜éƒ¨å¾®å¼¯',
                        'æ§åˆ¶åŠ¨ä½œé€Ÿåº¦',
                        'æ³¨æ„å‘¼å¸é…åˆ'
                    ],
                    'elbow_flexion': [
                        'ä¸Šè‡‚ä¿æŒå›ºå®š',
                        'ä¸“æ³¨å‰è‡‚è¿åŠ¨',
                        'åŠ¨ä½œç»ˆç‚¹ä¿æŒ1-2ç§’',
                        'é¿å…æ‰‹è…•å¼¯æ›²'
                    ]
                };
            }
            
            async getDetailedFeedback(features, exerciseType, confidence) {
                try {
                    const response = await fetch(API_BASE_URL+'/detailed_feedback', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            },
                        body: JSON.stringify({
                            features: features,
                            exercise_type: exerciseType,
                            category: 'upper_limb',
                            confidence: confidence,
                            predicted_class: 0  // æ·»åŠ å¿…éœ€çš„predicted_classå­—æ®µ
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    return data.detailed_feedback;
                } catch (error) {
                    console.error('è·å–è¯¦ç»†åé¦ˆå¤±è´¥:', error);
                    return this.getFallbackFeedback(exerciseType, confidence);
                }
            }
            
            getFallbackFeedback(exerciseType, confidence) {
                return {
                    overall_quality: confidence > 0.7 ? 'good' : 'needs_improvement',
                    suggestions: confidence > 0.7 ? 
                        ['ç»§ç»­ä¿æŒå½“å‰è®­ç»ƒçŠ¶æ€'] : 
                        ['æ”¾æ…¢åŠ¨ä½œé€Ÿåº¦', 'æ³¨æ„åŠ¨ä½œè§„èŒƒæ€§'],
                    technical_tips: this.technicalTips[exerciseType] || ['ä¿æŒèº«ä½“ç¨³å®š', 'æ§åˆ¶åŠ¨ä½œèŠ‚å¥']
                };
            }
            
            displayEnhancedFeedback(feedback) {
                const feedbackElement = document.getElementById('feedbackMessage');
                if (!feedbackElement) return;
                if (!feedback || typeof feedback !== 'object' || feedback.overall_quality === undefined) {
                    feedbackElement.innerHTML = '<div class="enhanced-feedback"><div class="text-warning">æš‚æ— è¯¦ç»†åé¦ˆæ•°æ®</div></div>';
                    return;
                }
                let qualityColor = 'text-accent';
                let qualityIcon = 'fa-info-circle';
                if (feedback.overall_quality === 'excellent') {
                    qualityColor = 'text-success';
                    qualityIcon = 'fa-check-circle';
                } else if (feedback.overall_quality === 'needs_improvement') {
                    qualityColor = 'text-warning';
                    qualityIcon = 'fa-exclamation-triangle';
                }
                let feedbackHTML = `
                    <div class="enhanced-feedback">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <i class="fas ${qualityIcon} text-xl ${qualityColor}"></i>
                            <div>
                                <div class="font-bold">åŠ¨ä½œè´¨é‡: ${this.getQualityText(feedback.overall_quality)}</div>
                                <div class="text-sm">ç½®ä¿¡åº¦: ${(feedback.confidence * 100).toFixed(1)}%</div>
                            </div>
                        </div>
                `;
                // æ·»åŠ æŠ€æœ¯æŒ‡æ ‡
                if (feedback.progress_indicators) {
                    feedbackHTML += '<div class="quality-indicators" style="margin: 10px 0;">';
                    for (const [indicator, value] of Object.entries(feedback.progress_indicators)) {
                        feedbackHTML += `
                            <div class="quality-indicator">
                                <span class="text-sm">${this.getIndicatorText(indicator)}:</span>
                                <div class="quality-bar">
                                    <div class="quality-fill" style="width: ${value * 100}%"></div>
                                </div>
                                <span class="text-sm">${(value * 100).toFixed(0)}%</span>
                            </div>
                        `;
                    }
                    feedbackHTML += '</div>';
                }
                // æ·»åŠ æŠ€æœ¯å»ºè®®
                if (feedback.technical_tips && feedback.technical_tips.length > 0) {
                    feedbackHTML += '<div class="technical-tips">';
                    feedbackHTML += '<div class="font-bold text-sm mb-2">æŠ€æœ¯è¦ç‚¹:</div>';
                    feedback.technical_tips.forEach(tip => {
                        feedbackHTML += `<div class="text-sm">â€¢ ${tip}</div>`;
                    });
                    feedbackHTML += '</div>';
                }
                feedbackHTML += '</div>';
                feedbackElement.innerHTML = feedbackHTML;
            }
            
            getQualityText(quality) {
                const texts = {
                    'excellent': 'ä¼˜ç§€',
                    'good': 'è‰¯å¥½',
                    'acceptable': 'åˆæ ¼',
                    'needs_improvement': 'éœ€è¦æ”¹è¿›'
                };
                return texts[quality] || quality;
            }
            
            getIndicatorText(indicator) {
                const texts = {
                    'form_consistency': 'å§¿åŠ¿ä¸€è‡´æ€§',
                    'movement_smoothness': 'åŠ¨ä½œæµç•…åº¦',
                    'range_of_motion': 'æ´»åŠ¨èŒƒå›´'
                };
                return texts[indicator] || indicator;
            }
        }

        // ========== è¿›åº¦å¯è§†åŒ– ==========
        class ProgressVisualization {
            constructor() {
                this.overallProgress = 0;
            }
            
            updateOverallProgress() {
                if (exerciseList.length === 0) return;
                
                const completedExercises = exerciseList.filter(ex => ex.completed).length;
                const totalExercises = exerciseList.length;
                const repProgress = completedReps / targetReps;
                
                this.overallProgress = Math.min(100, 
                    (completedExercises / totalExercises * 70) + // 70%æƒé‡ç»™å®ŒæˆåŠ¨ä½œ
                    (repProgress * 30) // 30%æƒé‡ç»™é‡å¤æ¬¡æ•°
                );
                
                this.renderProgressBar();
                this.updateStatistics();
            }
            
            renderProgressBar() {
                let progressBar = document.getElementById('overallProgressBar');
                if (!progressBar) {
                    const statsSection = document.querySelector('.card-gradient');
                    if (statsSection) {
                        const progressHTML = `
                            <div class="progress-visualization">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-bold">æ•´ä½“è¿›åº¦</span>
                                    <span id="progressPercentage">0%</span>
                                </div>
                                <div class="progress-container">
                                    <div id="overallProgressBar" class="progress-bar" style="width: 0%"></div>
                                </div>
                                <div id="progressStats" class="text-sm mt-2"></div>
                            </div>
                        `;
                        statsSection.insertAdjacentHTML('afterend', progressHTML);
                        progressBar = document.getElementById('overallProgressBar');
                    }
                }
                
                if (progressBar) {
                    progressBar.style.width = `${this.overallProgress}%`;
                    document.getElementById('progressPercentage').textContent = 
                        `${Math.round(this.overallProgress)}%`;
                }
            }
            
            updateStatistics() {
                const statsElement = document.getElementById('progressStats');
                if (!statsElement) return;
                
                const completedExercises = exerciseList.filter(ex => ex.completed).length;
                const totalExercises = exerciseList.length;
                const totalRepsCompleted = exerciseList.reduce((sum, ex) => sum + (ex.completedReps || 0), 0);
                
                statsElement.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>å®ŒæˆåŠ¨ä½œ: ${completedExercises}/${totalExercises}</div>
                        <div>æ€»é‡å¤æ¬¡æ•°: ${totalRepsCompleted}</div>
                        <div>å½“å‰å‡†ç¡®ç‡: ${document.getElementById('accuracyRate').textContent}</div>
                        <div>è®­ç»ƒæ—¶é•¿: ${document.getElementById('trainingTime').textContent}</div>
                    </div>
                `;
            }
        }

        // ========== é¡µé¢åˆå§‹åŒ– ==========
        function runAppInit() {
            console.log('åº·å¤è®­ç»ƒé¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–ç³»ç»Ÿ...');

            try {
                // åˆå§‹åŒ–å…ƒç´ å¼•ç”¨
                videoElement = document.getElementById('webcam');
                canvasElement = document.getElementById('output_canvas');

                // åˆå§‹åŒ–è¯­éŸ³åŠ©æ‰‹
                voiceAssistant = new VoiceAssistant();

                // åˆå§‹åŒ–è®­ç»ƒå†å²å›¾è¡¨
                initializeTrainingChart();
                
                // åˆå§‹åŒ–å§¿æ€æ•°æ®å›¾è¡¨
                initializePoseChart();

                // åŠ è½½å‘å¸ƒçš„æ¨¡å‹
                loadPublishedModel();

                // åŠ è½½ä¿å­˜çš„ä¸ªæ€§åŒ–è®¾ç½®
                loadCustomization();

                // åŠ è½½è®­ç»ƒå†å²
                loadTrainingHistory();

                // åˆå§‹åŒ–å¢å¼ºç³»ç»Ÿ
                initializeEnhancedSystems();

                // æ›´æ–°è¯­è¨€
                updateLanguage();

                console.log('åº·å¤è®­ç»ƒç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                showTemporaryMessage('ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œä½†åŸºæœ¬åŠŸèƒ½ä»å¯ä½¿ç”¨', 'warning');
            }
        }

        function initializeEnhancedSystems() {
            console.log('åˆå§‹åŒ–å¢å¼ºç³»ç»Ÿ...');
            
            // åˆå§‹åŒ–å„ç³»ç»Ÿ
            visualGuideSystem = new VisualGuideSystem();
            stepIndicator = new StepIndicator('stepIndicatorContainer');
            smartTrainingMode = new SmartTrainingMode();
            achievementSystem = new AchievementSystem();
            restReminderSystem = new RestReminderSystem();
            enhancedFeedbackSystem = new EnhancedFeedbackSystem();
            progressVisualization = new ProgressVisualization();
            
            // æ›´æ–°æˆå°±æ˜¾ç¤º
            achievementSystem.updateAchievementDisplay();
            
            console.log('å¢å¼ºç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        }

        document.addEventListener('DOMContentLoaded', function() {
            runAppInit();
        });

        // ========== å§¿æ€æ•°æ®å›¾è¡¨é…ç½® ==========
        const poseMetricConfig = {
            'elbow_flexion': { labelKey: 'elbow_flexion', compute: (lm) => {
                const r = computeElbowAngle(lm, 'right');
                return r !== null ? r : computeElbowAngle(lm, 'left');
            }},
            'shoulder_flexion': { labelKey: 'shoulder_flexion', compute: (lm) => {
                const r = computeShoulderAngle(lm, 'right');
                return r !== null ? r : computeShoulderAngle(lm, 'left');
            }},
            'shoulder_abduction': { labelKey: 'shoulder_abduction', compute: (lm) => {
                const r = computeShoulderAngle(lm, 'right');
                return r !== null ? r : computeShoulderAngle(lm, 'left');
            }},
            'wrist_flexion': { labelKey: 'wrist_flexion', compute: (lm) => {
                const r = computeWristAngle(lm, 'right');
                return r !== null ? r : computeWristAngle(lm, 'left');
            }},
            'arm_rotation': { labelKey: 'arm_rotation', compute: (lm) => {
                // fallback to elbow angle if no better metric
                const r = computeArmRotation(lm, 'right');
                return r !== null ? r : computeArmRotation(lm, 'left');
            }}
        };

        // ========== MediaPipe Pose åˆå§‹åŒ– ==========
        async function initPose() {
            try {
                // å¦‚æœå·²ç»åˆå§‹åŒ–å¹¶ä¸”æ˜¯å®é™… Pose å®ä¾‹ï¼Œåˆ™ç›´æ¥è¿”å›
                if (pose && typeof pose.send === 'function' && typeof pose.onResults === 'function') {
                    return;
                }

                console.log('Initializing MediaPipe Pose (real)...');

                // ä½¿ç”¨å…¨å±€ Poseï¼ˆé€šè¿‡ head ä¸­å¼•å…¥çš„è„šæœ¬ï¼‰
                pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });

                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    selfieMode: true
                });

                pose.onResults(onPoseResults);

                console.log('MediaPipe Pose initialized successfully');
            } catch (error) {
                console.error('MediaPipe Pose initialization failed:', error);
                showTemporaryMessage(i18n[currentLanguage].mediapipeError, 'error');
            }
        }

        function onPoseResults(results) {
            const canvasElement = document.getElementById('output_canvas');
            if (!canvasElement) return;

            const canvasCtx = canvasElement.getContext('2d');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // ç»˜åˆ¶ camera å›¾åƒä½œä¸ºèƒŒæ™¯
            if (results.image) {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }

            // ä½¿ç”¨ drawing_utils æä¾›çš„ç»˜åˆ¶æ–¹æ³•ç»˜åˆ¶éª¨æ¶ä¸å…³é”®ç‚¹
            try {
                if (results.poseLandmarks) {
                    // è¿æ¥çº¿ä¸å…³é”®ç‚¹ï¼Œé¢œè‰²ä¸çº¿å®½å¯æŒ‰éœ€è°ƒæ•´
                    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF88', lineWidth: 4 });
                    drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FF5252', lineWidth: 2 });
                }
            } catch (e) {
                // å¦‚æœ drawing_utils ä¸å¯ç”¨åˆ™å›é€€åˆ°ç®€å•ç‚¹ç»˜åˆ¶
                if (results.poseLandmarks) {
                    canvasCtx.fillStyle = '#00FF00';
                    results.poseLandmarks.forEach((lm) => {
                        const x = lm.x * canvasElement.width;
                        const y = lm.y * canvasElement.height;
                        canvasCtx.beginPath();
                        canvasCtx.arc(x, y, 3, 0, 2 * Math.PI);
                        canvasCtx.fill();
                    });
                }
            }

            // å¦‚æœæ­£åœ¨è®­ç»ƒå¹¶ä¸”æœ‰å½“å‰è®­ç»ƒåŠ¨ä½œï¼Œåˆ™å¤„ç†å§¿æ€æ•°æ®ï¼ˆç”¨äºè®­ç»ƒ/ç»Ÿè®¡ï¼‰
            if (isTraining && currentExercise && results.poseLandmarks) {
                processPoseData(results.poseLandmarks);
            }

            // æ¯æ¬¡ç»“æœåˆ°è¾¾æ—¶ï¼Œæ ¹æ®å½“å‰æ‰€é€‰çš„åº¦é‡è®¡ç®—å¹¶æ›´æ–°å§¿æ€å›¾è¡¨
            if (results.poseLandmarks) {
                const metric = poseMetricConfig[currentPoseMetricKey] || poseMetricConfig['elbow_flexion'];
                let angle = null;
                try {
                    angle = metric.compute(results.poseLandmarks);
                } catch (e) {
                    console.warn('Error computing pose metric', e);
                    angle = null;
                }
                if (angle !== null) updatePoseChart(angle);
            }

            canvasCtx.restore();
        }

        // ========== æ‘„åƒå¤´æ§åˆ¶ ==========
        async function startCamera() {
            try {
                videoElement = document.getElementById('webcam');
                canvasElement = document.getElementById('output_canvas');

                if (!videoElement || !canvasElement) {
                    showTemporaryMessage(i18n[currentLanguage].cameraGeneralError, 'error');
                    return;
                }

                await initPose();

                // å¦‚æœå­˜åœ¨ MediaPipe Camera å·¥å…·ï¼Œåˆ™ä¼˜å…ˆä½¿ç”¨å®ƒï¼ˆå®ƒä¼šå¤„ç†é‡‡é›†ä¸å¸§å›è°ƒï¼‰
                if (typeof Camera !== 'undefined') {
                    // ä¿æŒ video å…ƒç´ éšè—ï¼Œä»…ä½¿ç”¨ canvas æ˜¾ç¤ºç”»é¢
                    videoElement.style.display = 'none';
                    canvasElement.style.display = 'block';

                    // åˆ›å»ºå¹¶å¯åŠ¨ MediaPipe Camera
                    camera = new Camera(videoElement, {
                        onFrame: async () => {
                            if (pose && typeof pose.send === 'function') {
                                try {
                                    await pose.send({ image: videoElement });
                                } catch (e) {
                                    console.warn('pose.send error (Camera):', e);
                                }
                            }
                        },
                        width: 640,
                        height: 480
                    });

                    await camera.start();

                    // åŒæ­¥ canvas å°ºå¯¸
                    canvasElement.width = videoElement.videoWidth || 640;
                    canvasElement.height = videoElement.videoHeight || 480;

                    const ph = document.getElementById('videoPlaceholder');
                    if (ph) ph.style.display = 'none';

                } else {
                    // å›é€€åˆ°æ ‡å‡† getUserMedia + animationFrame å¾ªç¯
                    const constraints = { video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }, audio: false };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = stream;
                    videoElement.playsInline = true;
                    await videoElement.play();

                    // ä¿æŒ video å…ƒç´ éšè—ï¼Œä»…ä½¿ç”¨ canvas æ˜¾ç¤ºç”»é¢
                    videoElement.style.display = 'none';
                    canvasElement.style.display = 'block';
                    canvasElement.width = videoElement.videoWidth || 640;
                    canvasElement.height = videoElement.videoHeight || 480;

                    const ph = document.getElementById('videoPlaceholder');
                    if (ph) ph.style.display = 'none';

                    const canvasCtx = canvasElement.getContext('2d');

                    function drawFrame() {
                        if (!videoElement.paused && !videoElement.ended) {
                            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                            if (pose && typeof pose.send === 'function') {
                                try { pose.send({ image: videoElement }); } catch (e) { console.warn('pose.send error:', e); }
                            }
                        }
                        animationFrameId = requestAnimationFrame(drawFrame);
                    }
                    drawFrame();

                    camera = {
                        stream: stream,
                        stop: function() {
                            if (animationFrameId) cancelAnimationFrame(animationFrameId);
                            try { stream.getTracks().forEach(t => t.stop()); } catch (e) { console.warn('Error stopping media tracks', e); }
                        }
                    };
                }

                // UI çŠ¶æ€æ›´æ–°
                const cameraBtn = document.getElementById('cameraToggle');
                const startTrainingBtn = document.getElementById('startTrainingBtn');

                if (cameraBtn) {
                    cameraBtn.innerHTML = '<i class="fas fa-camera-slash"></i><span class="btn-text">' + 
                        (currentLanguage === 'zh' ? 'å…³é—­æ‘„åƒå¤´' : 'Stop Camera') + '</span>';
                    cameraBtn.classList.remove('btn-primary');
                    cameraBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                }

                if (startTrainingBtn) startTrainingBtn.disabled = false;

                showTemporaryMessage(i18n[currentLanguage].cameraStarted, 'success');
                console.log('Camera started successfully (real)');

            } catch (error) {
                console.error('Camera startup error:', error);
                if (error && (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError')) {
                    showTemporaryMessage(i18n[currentLanguage].cameraPermissionError, 'error');
                } else if (error && error.name === 'NotFoundError') {
                    showTemporaryMessage(i18n[currentLanguage].cameraNotFoundError, 'error');
                } else {
                    showTemporaryMessage(i18n[currentLanguage].cameraGeneralError, 'error');
                }
            }
        }

        function stopCamera() {
            if (camera) {
                // å¦‚æœ camera æ˜¯åŒ…å« stream çš„çœŸå®æ‘„åƒå¤´å¯¹è±¡ï¼Œåˆ™åœæ­¢ tracks
                try {
                    camera.stop();
                } catch (e) {
                    console.warn('camera.stop error', e);
                }
                camera = null;
            }
            
            if (isTraining) {
                stopTraining();
            }
            
            // UI çŠ¶æ€æ›´æ–°
            const cameraBtn = document.getElementById('cameraToggle');
            const startTrainingBtn = document.getElementById('startTrainingBtn');
            
            if (cameraBtn) {
                cameraBtn.innerHTML = '<i class="fas fa-camera"></i><span class="btn-text">' + i18n[currentLanguage].cameraBtnText + '</span>';
                cameraBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                cameraBtn.classList.add('btn-primary');
            }
            
            if (startTrainingBtn) startTrainingBtn.disabled = true;
            
            // æ˜¾ç¤ºå ä½ç¬¦å¹¶éšè—è§†é¢‘/ç”»å¸ƒ
            const ph = document.getElementById('videoPlaceholder');
            if (ph) ph.style.display = 'block';
            if (videoElement) {
                try {
                    // æ¸…ç©º video srcObject
                    videoElement.pause();
                    videoElement.srcObject = null;
                } catch (e) {}
                videoElement.style.display = 'none';
            }
            if (canvasElement) canvasElement.style.display = 'none';
            
            showTemporaryMessage(i18n[currentLanguage].cameraStopped, 'info');
        }

        // æ‘„åƒå¤´åˆ‡æ¢å‡½æ•°
        function toggleCamera() {
            if (camera) {
                stopCamera();
            } else {
                startCamera();
            }
        }

        // ========== è®­ç»ƒæ§åˆ¶ ==========
        function startTraining() {
            if (!currentExercise) {
                showTemporaryMessage(i18n[currentLanguage].noExerciseSelected, 'warning');
                return;
            }
            
            if (!camera) {
                showTemporaryMessage(i18n[currentLanguage].noCameraStarted, 'warning');
                return;
            }
            
            isTraining = true;
            trainingStartTime = new Date();
            completedReps = 0;
            correctPredictions = 0;
            totalPredictions = 0;
            lastRepTime = 0;
            
            // æ˜¾ç¤ºè§†è§‰å¼•å¯¼
            visualGuideSystem.showTargetPose(currentExercise.key);
            
            // å¯åŠ¨æ­¥éª¤æŒ‡ç¤ºå™¨
            const steps = {
                'shoulder_flexion': ['å‡†å¤‡å§¿åŠ¿', 'ç¼“æ…¢å‰ä¸¾', 'åˆ°è¾¾é¡¶ç‚¹', 'æ§åˆ¶æ”¾ä¸‹'],
                'elbow_flexion': ['æ‰‹è‡‚ä½ç½®', 'å¼¯æ›²è‚˜éƒ¨', 'ä¿æŒé¡¶å³°', 'ä¼¸ç›´æ‰‹è‡‚'],
                'shoulder_abduction': ['ç«™ç«‹å§¿åŠ¿', 'ä¾§å¹³ä¸¾æ‰‹', 'ä¿æŒæ°´å¹³', 'ç¼“æ…¢æ”¾ä¸‹']
            };
            
            stepIndicator.setSteps(steps[currentExercise.key] || ['å‡†å¤‡', 'æ‰§è¡Œ', 'å®Œæˆ']);
            stepIndicator.reset();
            
            // å¯åŠ¨ä¼‘æ¯æé†’ç›‘æ§
            restReminderSystem.startMonitoring();
            
            // æ›´æ–°UI
            const startTrainingBtn = document.getElementById('startTrainingBtn');
            if (startTrainingBtn) {
                startTrainingBtn.innerHTML = '<i class="fas fa-stop"></i><span class="btn-text">' + 
                    (currentLanguage === 'zh' ? 'åœæ­¢è®­ç»ƒ' : 'Stop Training') + '</span>';
                startTrainingBtn.classList.remove('btn-success');
                startTrainingBtn.classList.add('bg-red-500', 'hover:bg-red-600');
            }
            
            // å¼€å§‹è®¡æ—¶å™¨
            startTrainingTimer();
            
            // è¯­éŸ³æé†’è®­ç»ƒå¼€å§‹
            if (voiceAssistant) {
                voiceAssistant.trainingStart();
            }
            
            // æ›´æ–°åé¦ˆ
            const startFeedback = i18n[currentLanguage].startExerciseFeedback.replace('{exercise}', currentExercise.name);
            updateFeedback(startFeedback);
            
            showTemporaryMessage(i18n[currentLanguage].trainingStarted, 'success');
        }

        function stopTraining() {
            isTraining = false;
            
            // æ¸…é™¤è§†è§‰å¼•å¯¼
            visualGuideSystem.clearGuides();
            
            // åœæ­¢ä¼‘æ¯æé†’
            restReminderSystem.stopMonitoring();
            
            // æ›´æ–°UI
            const startTrainingBtn = document.getElementById('startTrainingBtn');
            if (startTrainingBtn) {
                startTrainingBtn.innerHTML = '<i class="fas fa-play-circle"></i><span class="btn-text">' + i18n[currentLanguage].trainingBtnText + '</span>';
                startTrainingBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                startTrainingBtn.classList.add('btn-success');
            }
            
            // åœæ­¢è®¡æ—¶å™¨
            clearInterval(trainingTimer);
            
            // æ£€æŸ¥æˆå°±
            const sessionData = {
                session_count: parseInt(localStorage.getItem('rehab_session_count') || '0') + 1,
                accuracy: totalPredictions > 0 ? correctPredictions / totalPredictions : 0,
                total_reps: completedReps,
                current_streak: completedReps,
                weekly_sessions: 1 // ç®€åŒ–å®ç°
            };
            
            achievementSystem.checkAndUnlock(sessionData);
            
            // è¯­éŸ³æé†’è®­ç»ƒç»“æŸï¼ˆå¦‚æœå®Œæˆäº†ç›®æ ‡ï¼‰
            if (completedReps >= targetReps && voiceAssistant) {
                voiceAssistant.trainingComplete();
            }
            
            // ä¿å­˜è®­ç»ƒè®°å½•
            saveTrainingRecord();
            
            // æ›´æ–°è¿›åº¦å¯è§†åŒ–
            progressVisualization.updateOverallProgress();
            
            // æ›´æ–°åé¦ˆ
            updateFeedback(i18n[currentLanguage].trainingStoppedFeedback);
            
            showTemporaryMessage(i18n[currentLanguage].trainingStopped, 'info');
        }

        function toggleTraining() {
            if (isTraining) {
                stopTraining();
            } else {
                startTraining();
            }
        }

        function resetTraining() {
            if (isTraining) {
                stopTraining();
            }
            
            completedReps = 0;
            correctPredictions = 0;
            totalPredictions = 0;
            
            // é‡ç½®æ­¥éª¤æŒ‡ç¤ºå™¨
            stepIndicator.reset();
            
            updateTrainingStats();
            updateFeedback(i18n[currentLanguage].trainingResetFeedback);
            
            showTemporaryMessage(i18n[currentLanguage].trainingReset, 'info');
        }

        function startTrainingTimer() {
            trainingTimer = setInterval(() => {
                const now = new Date();
                const diff = Math.floor((now - trainingStartTime) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                
                document.getElementById('trainingTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // ========== å§¿æ€æ•°æ®å¤„ç†ä¸æ¨¡å‹é¢„æµ‹ ==========
        function processPoseData(landmarks) {
            if (!landmarks || !publishedModel) return;
            
            // æ¨¡æ‹Ÿç‰¹å¾æå–
            const features = extractUpperLimbFeatures(landmarks);
            
            // å‘é€åˆ°åç«¯è¿›è¡Œé¢„æµ‹
            predictExercise(features);
            
            // æ›´æ–°é¢„æµ‹ç»Ÿè®¡
            totalPredictions++;
            updateTrainingStats();
        }

        function extractUpperLimbFeatures(landmarks) {
            // æ¨¡æ‹Ÿç‰¹å¾æå–
            const features = [];
            for (let i = 0; i < 20; i++) {
                features.push(Math.random());
            }
            return features;
        }

        async function predictExercise(features) {
            try {
                if (!publishedModel) return;
                
                // æ¨¡æ‹Ÿé¢„æµ‹è¯·æ±‚
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const mockResult = {
                    prediction: {
                        predicted_class: currentExercise ? currentExercise.key : 'shoulder_flexion',
                        confidence: 0.7 + Math.random() * 0.25
                    }
                };
                
                // å¤„ç†é¢„æµ‹ç»“æœ
                handlePredictionResult(mockResult);
                
            } catch (error) {
                console.error('Prediction request error:', error);
            }
        }

        async function handlePredictionResult(result) {
            if (result.error) {
                console.error('Prediction error:', result.error);
                return;
            }
            
            const prediction = result.prediction;
            const predictedClass = prediction.predicted_class;
            const confidence = prediction.confidence;
            const currentTime = Date.now();
            
            //console.log(`Prediction result: class=${predictedClass}, confidence=${confidence.toFixed(3)}`);
            
            // å¦‚æœç½®ä¿¡åº¦è¶³å¤Ÿé«˜ï¼Œå¹¶ä¸”é¢„æµ‹çš„åŠ¨ä½œä¸å½“å‰è®­ç»ƒåŠ¨ä½œåŒ¹é…
            if (confidence > 0.7 && currentExercise && predictedClass === currentExercise.key) {
                // æ£€æŸ¥å†·å´æ—¶é—´ï¼Œé˜²æ­¢é‡å¤è®¡æ•°
                if (currentTime - lastRepTime > REP_COOLDOWN) {
                    correctPredictions++;
                    
                    // æ¯Næ¬¡æ­£ç¡®é¢„æµ‹è®¡ä¸ºä¸€æ¬¡å®Œæ•´åŠ¨ä½œï¼ˆæ ¹æ®åŠ¨ä½œå¤æ‚åº¦è°ƒæ•´ï¼‰
                    const repsPerPrediction = getRepsPerPrediction(currentExercise.key);
                    
                    if (correctPredictions % repsPerPrediction === 0) {
                        completedReps++;
                        lastRepTime = currentTime;
                        
                        // æ›´æ–°æ­¥éª¤æŒ‡ç¤ºå™¨
                        stepIndicator.nextStep();
                        
                        // æ›´æ–°UIå’Œç»Ÿè®¡
                        updateTrainingStats();
                        
                        // æ›´æ–°è¿›åº¦å¯è§†åŒ–
                        progressVisualization.updateOverallProgress();
                        
                        // è·å–å¢å¼ºåé¦ˆ
                        const detailedFeedback = await enhancedFeedbackSystem.getDetailedFeedback(
                            extractUpperLimbFeatures([]), // è¿™é‡Œåº”è¯¥ä¼ å…¥å®é™…çš„ç‰¹å¾
                            currentExercise.key,
                            confidence
                        );
                        enhancedFeedbackSystem.displayEnhancedFeedback(detailedFeedback);
                        
                        // è¯­éŸ³æé†’å®Œæˆæ¬¡æ•°
                        if (voiceAssistant && completedReps > 0) {
                            voiceAssistant.exerciseComplete(completedReps, targetReps);
                        }
                        
                        // æä¾›åé¦ˆ
                        if (completedReps < targetReps) {
                            const progressFeedback = i18n[currentLanguage].exerciseProgressFeedback
                                .replace('{completed}', completedReps)
                                .replace('{target}', targetReps);
                            updateFeedback(progressFeedback, 'success');
                        } else {
                            const completedFeedback = i18n[currentLanguage].exerciseCompletedFeedback
                                .replace('{target}', targetReps);
                            updateFeedback(completedFeedback, 'success');
                            if (voiceAssistant) {
                                voiceAssistant.trainingComplete();
                            }
                            completeCurrentExercise();
                        }
                    }
                }
            } else if (confidence < 0.4) {
                // ç½®ä¿¡åº¦ä½ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´åŠ¨ä½œ
                if (voiceAssistant && Math.random() < 0.1) { // 10%æ¦‚ç‡æé†’ï¼Œé¿å…è¿‡äºé¢‘ç¹
                    voiceAssistant.correctionNeeded();
                }
                
                // æ˜¾ç¤ºæŠ€æœ¯å»ºè®®
                const detailedFeedback = await enhancedFeedbackSystem.getDetailedFeedback(
                    extractUpperLimbFeatures([]),
                    currentExercise.key,
                    confidence
                );
                enhancedFeedbackSystem.displayEnhancedFeedback(detailedFeedback);
            }
        }

        // æ ¹æ®åŠ¨ä½œç±»å‹ç¡®å®šæ¯æ¬¡å®Œæ•´åŠ¨ä½œéœ€è¦çš„é¢„æµ‹æ¬¡æ•°
        function getRepsPerPrediction(exerciseKey) {
            const repsMap = {
                'shoulder_flexion': 8,    // è‚©éƒ¨å±ˆæ›²éœ€è¦8æ¬¡é«˜ç½®ä¿¡åº¦é¢„æµ‹
                'shoulder_abduction': 10, // è‚©éƒ¨å¤–å±•éœ€è¦10æ¬¡
                'elbow_flexion': 6,       // è‚˜éƒ¨å±ˆæ›²éœ€è¦6æ¬¡
                'wrist_flexion': 12,      // è…•éƒ¨å±ˆæ›²éœ€è¦12æ¬¡
                'arm_rotation': 15        // æ‰‹è‡‚æ—‹è½¬éœ€è¦15æ¬¡
            };
            
            return repsMap[exerciseKey] || 10; // é»˜è®¤10æ¬¡
        }

        // ========== åº·å¤è®¡åˆ’ç®¡ç† ==========
        function loadExerciseList() {
            const exerciseListElement = document.getElementById('exerciseList');
            if (!exerciseListElement) return;
            
            exerciseListElement.innerHTML = '';
            
            exerciseList.forEach((exercise, index) => {
                const exerciseCard = document.createElement('div');
                exerciseCard.className = `exercise-card ${index === currentExerciseIndex ? 'active' : ''} ${exercise.completed ? 'completed' : ''}`;
                
                const difficultyText = i18n[currentLanguage][exercise.difficulty] || exercise.difficulty;
                
                exerciseCard.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-bold">${exercise.name}</h3>
                        <span class="text-sm bg-white/20 px-2 py-1 rounded">${difficultyText}</span>
                    </div>
                    <p class="text-sm opacity-80 mb-2">${exercise.description}</p>
                    <div class="flex justify-between items-center text-sm">
                        <span>${i18n[currentLanguage].targetRepsLabel}: ${exercise.targetReps} ${currentLanguage === 'zh' ? 'æ¬¡' : 'reps'}</span>
                        <span>${currentLanguage === 'zh' ? 'å®Œæˆ:' : 'Completed:'} ${exercise.completedReps || 0} ${currentLanguage === 'zh' ? 'æ¬¡' : 'reps'}</span>
                    </div>
                `;
                
                exerciseCard.addEventListener('click', () => {
                    selectExercise(index);
                });
                
                exerciseListElement.appendChild(exerciseCard);
            });
        }

        function selectExercise(index) {
            if (index < 0 || index >= exerciseList.length) return;
            
            currentExerciseIndex = index;
            currentExercise = exerciseList[index];
            
            // æ›´æ–°UI
            document.getElementById('currentExercise').textContent = currentExercise.name;
            document.getElementById('targetReps').textContent = currentExercise.targetReps;
            
            // æ›´æ–°è®­ç»ƒç›®æ ‡
            targetReps = currentExercise.targetReps;
            completedReps = currentExercise.completedReps || 0;
            
            // æ›´æ–°è®­ç»ƒç»Ÿè®¡
            updateTrainingStats();

            // æ ¹æ®æ‰€é€‰åŠ¨ä½œåˆ‡æ¢å§¿æ€å›¾è¡¨çš„åº¦é‡å’Œæ ‡ç­¾
            currentPoseMetricKey = currentExercise.key || 'elbow_flexion';
            if (poseDataChart) {
                const metric = poseMetricConfig[currentPoseMetricKey] || poseMetricConfig['elbow_flexion'];
                const labelText = i18n[currentLanguage][metric.labelKey] || metric.labelKey;
                poseDataChart.data.datasets[0].label = labelText;
                poseDataChart.data.labels = [];
                poseDataChart.data.datasets[0].data = [];
                poseDataChart.update();
            }
            
            // æ›´æ–°åº·å¤è®¡åˆ’UI
            loadExerciseList();
            
            // æ›´æ–°åé¦ˆ
            const selectFeedback = currentLanguage === 'zh' ? 
                `å·²é€‰æ‹©${currentExercise.name}ï¼Œè¯·ç‚¹å‡»"å¼€å§‹è®­ç»ƒ"` :
                `Selected ${currentExercise.name}, please click "Start Training"`;
            updateFeedback(selectFeedback);
        }

        function completeCurrentExercise() {
            if (!currentExercise) return;
            
            // æ ‡è®°å½“å‰åŠ¨ä½œä¸ºå®Œæˆ
            currentExercise.completed = true;
            currentExercise.completedReps = completedReps;
            currentExercise.completedDate = new Date().toISOString();
            
            // æ›´æ–°UI
            loadExerciseList();
            
            // è‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªæœªå®Œæˆçš„åŠ¨ä½œ
            const nextExerciseIndex = exerciseList.findIndex(ex => !ex.completed);
            if (nextExerciseIndex !== -1) {
                selectExercise(nextExerciseIndex);
            } else {
                // æ‰€æœ‰åŠ¨ä½œå·²å®Œæˆ
                updateFeedback(i18n[currentLanguage].allExercisesCompleted, 'success');
                showTemporaryMessage(i18n[currentLanguage].planCompleted, 'success');
            }
        }

        // ========== æ™ºèƒ½è®­ç»ƒå¯åŠ¨å‡½æ•° ==========
        async function startSmartTraining() {
            const success = await smartTrainingMode.startSmartTraining();
            if (success) {
                showTemporaryMessage(
                    currentLanguage === 'zh' ? 'æ™ºèƒ½è®­ç»ƒè®¡åˆ’å·²å¯åŠ¨' : 'Smart training plan started',
                    'success'
                );
            } else {
                showTemporaryMessage(
                    currentLanguage === 'zh' ? 'æ™ºèƒ½è®­ç»ƒå¯åŠ¨å¤±è´¥' : 'Smart training failed to start',
                    'error'
                );
            }
        }

        // ========== æ¨¡å‹ç®¡ç† ==========
        function loadPublishedModel() {
            // ä»localStorageè·å–å‘å¸ƒçš„æ¨¡å‹ä¿¡æ¯
            const publishedModelStr = localStorage.getItem('published_upper_limb_model');
            
            if (!publishedModelStr) {
                // åˆ›å»ºæ¨¡æ‹Ÿæ¨¡å‹æ•°æ®
                publishedModel = {
                    modelName: 'UpperLimbRehabModel_v1.2',
                    category: 'upper_limb',
                    config: {
                        final_accuracy: 0.89
                    }
                };
                
                // ä¿å­˜åˆ°localStorage
                localStorage.setItem('published_upper_limb_model', JSON.stringify(publishedModel));
            } else {
                try {
                    publishedModel = JSON.parse(publishedModelStr);
                } catch (error) {
                    console.error('Error parsing published model:', error);
                    showTemporaryMessage(i18n[currentLanguage].noModelFound, 'warning');
                    return;
                }
            }
            
            // æ›´æ–°UI
            document.getElementById('currentModelName').textContent = publishedModel.modelName;
            document.getElementById('modelStatus').textContent = i18n[currentLanguage].loaded;
            document.getElementById('modelStatus').classList.remove('text-warning');
            document.getElementById('modelStatus').classList.add('text-success');
            
            // å¦‚æœæœ‰å‡†ç¡®ç‡ä¿¡æ¯ï¼Œæ˜¾ç¤ºå‡ºæ¥
            if (publishedModel.config && publishedModel.config.final_accuracy) {
                const accuracy = (publishedModel.config.final_accuracy * 100).toFixed(1);
                document.getElementById('modelAccuracy').textContent = `${accuracy}%`;
            }
            
            showTemporaryMessage(i18n[currentLanguage].modelLoaded + `: ${publishedModel.modelName}`, 'success');
        }

        // ========== ä¸ªæ€§åŒ–è®¾ç½® ==========
        function showCustomizeModal() {
            document.getElementById('customizeModal').style.display = 'flex';
        }

        function closeCustomizeModal() {
            document.getElementById('customizeModal').style.display = 'none';
        }

        function saveCustomization() {
            // è·å–è®¾ç½®å€¼
            const patientName = document.getElementById('patientName').value;
            const customTargetReps = parseInt(document.getElementById('customTargetReps').value);
            const trainingDifficulty = document.getElementById('trainingDifficulty').value;
            
            // è·å–é€‰ä¸­çš„åº·å¤åŠ¨ä½œ
            const selectedExercises = [];
            document.querySelectorAll('#customizeModal input[type="checkbox"]:checked').forEach(checkbox => {
                selectedExercises.push(checkbox.value);
            });
            
            // æ›´æ–°åº·å¤è®¡åˆ’
            updateExercisePlan(selectedExercises, customTargetReps, trainingDifficulty);
            
            // ä¿å­˜åˆ°localStorage
            const customization = {
                patientName,
                targetReps: customTargetReps,
                difficulty: trainingDifficulty,
                selectedExercises,
                lastUpdated: new Date().toISOString()
            };
            
            localStorage.setItem('rehab_customization', JSON.stringify(customization));
            
            // å…³é—­æ¨¡æ€æ¡†
            closeCustomizeModal();
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showTemporaryMessage(i18n[currentLanguage].customizationSaved, 'success');
        }

        function loadCustomization() {
            const customizationStr = localStorage.getItem('rehab_customization');
            
            if (customizationStr) {
                try {
                    const customization = JSON.parse(customizationStr);
                    
                    // åº”ç”¨è®¾ç½®
                    document.getElementById('patientName').value = customization.patientName || '';
                    document.getElementById('customTargetReps').value = customization.targetReps || 10;
                    document.getElementById('trainingDifficulty').value = customization.difficulty || 'medium';
                    
                    // é€‰ä¸­åº·å¤åŠ¨ä½œ
                    document.querySelectorAll('#customizeModal input[type="checkbox"]').forEach(checkbox => {
                        checkbox.checked = customization.selectedExercises?.includes(checkbox.value) || false;
                    });
                    
                    // æ›´æ–°åº·å¤è®¡åˆ’
                    updateExercisePlan(
                        customization.selectedExercises || ['shoulder_flexion', 'shoulder_abduction', 'elbow_flexion'],
                        customization.targetReps || 10,
                        customization.difficulty || 'medium'
                    );
                    
                } catch (error) {
                    console.error('Error loading customization:', error);
                }
            } else {
                // ä½¿ç”¨é»˜è®¤è®¾ç½®
                updateExercisePlan(['shoulder_flexion', 'shoulder_abduction', 'elbow_flexion'], 10, 'medium');
            }
        }

        function updateExercisePlan(selectedExercises, targetReps, difficulty) {
            exerciseList = selectedExercises.map(exerciseKey => {
                const exercise = exercises[exerciseKey];
                if (!exercise) {
                    console.error(`Exercise not found: ${exerciseKey}`);
                    return null;
                }
                
                return {
                    key: exerciseKey,
                    name: exercise.name[currentLanguage] || exercise.name.en,
                    description: exercise.description[currentLanguage] || exercise.description.en,
                    difficulty: exercise.difficulty,
                    targetReps: targetReps,
                    targetMuscles: exercise.targetMuscles[currentLanguage] || exercise.targetMuscles.en,
                    completed: false,
                    completedReps: 0
                };
            }).filter(ex => ex !== null); // è¿‡æ»¤æ‰ä¸å­˜åœ¨çš„åŠ¨ä½œ
            
            // æ ¹æ®éš¾åº¦è°ƒæ•´ç›®æ ‡æ¬¡æ•°
            if (difficulty === 'easy') {
                exerciseList.forEach(ex => ex.targetReps = Math.max(5, Math.floor(targetReps * 0.7)));
            } else if (difficulty === 'hard') {
                exerciseList.forEach(ex => ex.targetReps = Math.floor(targetReps * 1.3));
            }
            
            // æ›´æ–°UI
            loadExerciseList();
            
            // é€‰æ‹©ç¬¬ä¸€ä¸ªåŠ¨ä½œ
            if (exerciseList.length > 0) {
                selectExercise(0);
            }
        }

        // ========== è®­ç»ƒç»Ÿè®¡ä¸åé¦ˆ ==========
        function updateTrainingStats() {
            // æ›´æ–°å®Œæˆæ¬¡æ•°
            document.getElementById('completedReps').textContent = completedReps;
            document.getElementById('targetReps').textContent = targetReps;
            
            // æ›´æ–°å‡†ç¡®ç‡
            const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions * 100).toFixed(1) : 0;
            document.getElementById('accuracyRate').textContent = `${accuracy}%`;
        }

        function updateFeedback(message, type = 'info') {
            const feedbackElement = document.getElementById('feedbackMessage');
            if (!feedbackElement) return;
            
            let icon = 'fa-info-circle';
            let colorClass = 'text-accent';
            
            if (type === 'success') {
                icon = 'fa-check-circle';
                colorClass = 'text-success';
            } else if (type === 'warning') {
                icon = 'fa-exclamation-triangle';
                colorClass = 'text-warning';
            } else if (type === 'error') {
                icon = 'fa-times-circle';
                colorClass = 'text-danger';
            }
            
            feedbackElement.innerHTML = `
                <i class="fas ${icon} text-xl mb-2 ${colorClass}"></i>
                <div>${message}</div>
            `;
        }

        // ========== è®­ç»ƒå†å²ä¸å›¾è¡¨ ==========
        function initializeTrainingChart() {
            const ctx = document.getElementById('trainingHistoryChart').getContext('2d');
            
            trainingHistoryChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: trainingHistory.dates,
                    datasets: [
                        {
                            label: i18n[currentLanguage].accuracyChartLabel,
                            data: trainingHistory.accuracy,
                            borderColor: 'rgb(34, 197, 94)',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: i18n[currentLanguage].repsChartLabel,
                            data: trainingHistory.completedReps,
                            borderColor: 'rgb(99, 102, 241)',
                            backgroundColor: 'rgba(99, 102, 241, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: i18n[currentLanguage].trainingHistoryTitle,
                            font: {
                                size: 16
                            },
                            color: '#333'
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#333'
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: i18n[currentLanguage].accuracyChartLabel,
                                color: '#333'
                            },
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: i18n[currentLanguage].repsChartLabel,
                                color: '#333'
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#333'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: i18n[currentLanguage].trainingDateLabel,
                                color: '#333'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        }
                    }
                }
            });
        }

        function updateChartLanguage() {
            if (!trainingHistoryChart) return;
            
            trainingHistoryChart.data.datasets[0].label = i18n[currentLanguage].accuracyChartLabel;
            trainingHistoryChart.data.datasets[1].label = i18n[currentLanguage].repsChartLabel;
            trainingHistoryChart.options.plugins.title.text = i18n[currentLanguage].trainingHistoryTitle;
            trainingHistoryChart.options.scales.y.title.text = i18n[currentLanguage].accuracyChartLabel;
            trainingHistoryChart.options.scales.y1.title.text = i18n[currentLanguage].repsChartLabel;
            trainingHistoryChart.options.scales.x.title.text = i18n[currentLanguage].trainingDateLabel;
            
            trainingHistoryChart.update();
        }

        // ========== å§¿æ€æ•°æ®å›¾è¡¨ï¼ˆç®€æ˜“ï¼‰ ==========
        function computeElbowAngle(landmarks, side = 'right') {
            // MediaPipe Pose ç´¢å¼•: å·¦ä¾§ shoulder=11, elbow=13, wrist=15; å³ä¾§ shoulder=12, elbow=14, wrist=16
            const idx = (side === 'right') ? {s:12, e:14, w:16} : {s:11, e:13, w:15};
            if (!landmarks || !landmarks[idx.s] || !landmarks[idx.e] || !landmarks[idx.w]) return null;

            const s = landmarks[idx.s];
            const e = landmarks[idx.e];
            const w = landmarks[idx.w];

            // å‘é‡ ES å’Œ EW
            const v1 = { x: s.x - e.x, y: s.y - e.y };
            const v2 = { x: w.x - e.x, y: w.y - e.y };

            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            if (mag1 === 0 || mag2 === 0) return null;
            let cos = dot / (mag1 * mag2);
            cos = Math.min(1, Math.max(-1, cos));
            const angleRad = Math.acos(cos);
            const angleDeg = angleRad * 180 / Math.PI;
            return Math.round(angleDeg);
        }

        // è‚©éƒ¨è§’åº¦è®¡ç®—ï¼ˆä»¥è‚©å…³èŠ‚ä¸ºé¡¶ç‚¹ï¼Œè‚˜éƒ¨ä¸é«‹éƒ¨å‘é‡ä¹‹é—´çš„å¤¹è§’ï¼‰
        function computeShoulderAngle(landmarks, side = 'right') {
            // å·¦ä¾§ shoulder=11, elbow=13, hip=23; å³ä¾§ shoulder=12, elbow=14, hip=24
            const idx = (side === 'right') ? {s:12, e:14, h:24} : {s:11, e:13, h:23};
            if (!landmarks || !landmarks[idx.s] || !landmarks[idx.e] || !landmarks[idx.h]) return null;
            const s = landmarks[idx.s];
            const e = landmarks[idx.e];
            const h = landmarks[idx.h];
            const v1 = { x: e.x - s.x, y: e.y - s.y };
            const v2 = { x: h.x - s.x, y: h.y - s.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y);
            const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y);
            if (mag1 === 0 || mag2 === 0) return null;
            let cos = dot / (mag1 * mag2);
            cos = Math.min(1, Math.max(-1, cos));
            const angle = Math.acos(cos) * 180 / Math.PI;
            return Math.round(angle);
        }

        // è…•éƒ¨è§’åº¦è®¡ç®—ï¼ˆä»¥è…•å…³èŠ‚ä¸ºé¡¶ç‚¹ï¼Œå‰è‡‚ä¸æ‰‹æŒ‡æ–¹å‘ä¹‹é—´çš„å¤¹è§’ï¼‰
        function computeWristAngle(landmarks, side = 'right') {
            // å³ä¾§: elbow=14, wrist=16, index=20; å·¦ä¾§: elbow=13, wrist=15, index=19
            const idx = (side === 'right') ? {el:14, w:16, idx:20} : {el:13, w:15, idx:19};
            if (!landmarks || !landmarks[idx.el] || !landmarks[idx.w] || !landmarks[idx.idx]) return null;
            const el = landmarks[idx.el];
            const w = landmarks[idx.w];
            const ind = landmarks[idx.idx];
            const v1 = { x: el.x - w.x, y: el.y - w.y };
            const v2 = { x: ind.x - w.x, y: ind.y - w.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y);
            const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y);
            if (mag1 === 0 || mag2 === 0) return null;
            let cos = dot / (mag1 * mag2);
            cos = Math.min(1, Math.max(-1, cos));
            const angle = Math.acos(cos) * 180 / Math.PI;
            return Math.round(angle);
        }

        // æ‰‹è‡‚æ—‹è½¬åº¦é‡çš„è¿‘ä¼¼è®¡ç®—ï¼ˆç›®å‰ä½¿ç”¨è‚©-è‚˜-è…•çš„å¤¹è§’ä½œä¸ºè¿‘ä¼¼ï¼‰
        function computeArmRotation(landmarks, side = 'right') {
            // å¤ç”¨è‚˜éƒ¨è§’åº¦ä½œä¸ºè¿‘ä¼¼æŒ‡æ ‡
            return computeElbowAngle(landmarks, side);
        }

        function initializePoseChart() {
            const el = document.getElementById('poseDataChart');
            if (!el) return;
            const ctx = el.getContext('2d');
            poseChartData = [];
            // ä½¿ç”¨å½“å‰åº¦é‡çš„æ ‡ç­¾ï¼ˆå¤šè¯­è¨€æ”¯æŒï¼‰
            const metric = poseMetricConfig[currentPoseMetricKey] || poseMetricConfig['elbow_flexion'];
            let labelText = metric && metric.labelKey ? i18n[currentLanguage][metric.labelKey] : 'Metric';
            poseDataChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: labelText || 'Metric',
                        data: [],
                        borderColor: '#4facfe',
                        backgroundColor: 'rgba(79,172,254,0.18)',
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { display: false },
                        y: { min: 0, max: 180, title: { display: true, text: 'Angle (Â°)' } }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function updatePoseChart(angle) {
            if (!poseDataChart) return;
            const maxPoints = 80;
            const ds = poseDataChart.data.datasets[0];
            const labels = poseDataChart.data.labels;
            const now = new Date();
            labels.push(now.toLocaleTimeString());
            ds.data.push(angle);
            // ä¿æŒæ»‘åŠ¨çª—å£
            if (ds.data.length > maxPoints) {
                ds.data.shift();
                labels.shift();
            }
            poseDataChart.update('none');
        }

        function saveTrainingRecord() {
            if (!trainingStartTime || !currentExercise) return;
            
            const trainingEndTime = new Date();
            const duration = Math.floor((trainingEndTime - trainingStartTime) / 1000); // ç§’
            
            // è®¡ç®—å‡†ç¡®ç‡
            const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions * 100) : 0;
            
            // æ·»åŠ åˆ°å†å²è®°å½•
            trainingHistory.dates.push(trainingEndTime.toLocaleDateString());
            trainingHistory.accuracy.push(accuracy);
            trainingHistory.completedReps.push(completedReps);
            trainingHistory.duration.push(duration);
            
            // ä¿æŒæœ€è¿‘10æ¡è®°å½•
            if (trainingHistory.dates.length > 10) {
                trainingHistory.dates.shift();
                trainingHistory.accuracy.shift();
                trainingHistory.completedReps.shift();
                trainingHistory.duration.shift();
            }
            
            // æ›´æ–°å›¾è¡¨
            trainingHistoryChart.update();
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('rehab_training_history', JSON.stringify(trainingHistory));
        }

        function loadTrainingHistory() {
            const historyStr = localStorage.getItem('rehab_training_history');
            
            if (historyStr) {
                try {
                    trainingHistory = JSON.parse(historyStr);
                    
                    // æ›´æ–°å›¾è¡¨
                    if (trainingHistoryChart) {
                        trainingHistoryChart.data.labels = trainingHistory.dates;
                        trainingHistoryChart.data.datasets[0].data = trainingHistory.accuracy;
                        trainingHistoryChart.data.datasets[1].data = trainingHistory.completedReps;
                        trainingHistoryChart.update();
                    }
                    
                } catch (error) {
                    console.error('Error loading training history:', error);
                }
            }
        }

        // ========== å·¥å…·å‡½æ•° ==========
        function showTemporaryMessage(message, type = 'info') {
            const existingMessages = document.querySelectorAll('.temp-message');
            existingMessages.forEach(msg => msg.remove());
            
            const messageElement = document.createElement('div');
            messageElement.className = `temp-message ${type}`;
            messageElement.textContent = message;
            document.body.appendChild(messageElement);
            
            setTimeout(() => {
                if (messageElement.parentNode) {
                    messageElement.parentNode.removeChild(messageElement);
                }
            }, 3000);
        }

        // ========== è¯­è¨€åˆ‡æ¢åŠŸèƒ½ ==========
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
            localStorage.setItem('rehab_language', currentLanguage);
            updateLanguage();
        }

        function updateLanguage() {
            // æ›´æ–°é¡µé¢æ ‡é¢˜å’Œå‰¯æ ‡é¢˜
            const pageTitle = document.getElementById('page-title');
            const pageSubtitle = document.getElementById('page-subtitle');
            const langText = document.getElementById('lang-text');
            
            if (pageTitle) pageTitle.textContent = i18n[currentLanguage].pageTitle;
            if (pageSubtitle) pageSubtitle.textContent = i18n[currentLanguage].pageSubtitle;
            if (langText) langText.textContent = i18n[currentLanguage].langText;
            
            // æ›´æ–°å„éƒ¨åˆ†æ ‡é¢˜
            const sections = [
                'camera-section-title', 'stats-section-title', 'plan-section-title',
                'model-section-title', 'feedback-section-title', 'history-section-title',
                'pose-data-chart-title'
            ];
            
            sections.forEach(sectionId => {
                const element = document.getElementById(sectionId);
                if (element) element.textContent = i18n[currentLanguage][sectionId.replace(/-/g, '')];
            });
            
            // æ›´æ–°æ‘„åƒå¤´åŒºåŸŸ
            const cameraElements = [
                'camera-off-text', 'camera-hint', 'camera-btn-text', 
                'training-btn-text', 'reset-btn-text'
            ];
            
            cameraElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = i18n[currentLanguage][elementId.replace(/-/g, '')];
            });
            
            // æ›´æ–°è®­ç»ƒç»Ÿè®¡æ ‡ç­¾
            const statLabels = [
                'current-exercise-label', 'completed-reps-label', 
                'accuracy-label', 'training-time-label'
            ];
            
            statLabels.forEach(labelId => {
                const element = document.getElementById(labelId);
                if (element) element.textContent = i18n[currentLanguage][labelId.replace(/-/g, '')];
            });
            
            // æ›´æ–°æ¨¡å‹ä¿¡æ¯
            const modelElements = [
                'current-model-label', 'accuracy-label2', 'status-label', 'load-model-btn-text'
            ];
            
            modelElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = i18n[currentLanguage][elementId.replace(/-/g, '')];
            });
            
            // æ›´æ–°åº·å¤è®¡åˆ’
            const customizeBtn = document.getElementById('customize-btn-text');
            if (customizeBtn) customizeBtn.textContent = i18n[currentLanguage].customizeBtnText;
            
            // æ›´æ–°å®æ—¶åé¦ˆ
            const waitingFeedback = document.getElementById('waiting-feedback');
            if (waitingFeedback) waitingFeedback.textContent = i18n[currentLanguage].waitingFeedback;
            
            // æ›´æ–°æ¨¡æ€æ¡†
            const modalElements = [
                'customize-modal-title', 'patient-name-label', 'target-reps-label',
                'difficulty-label', 'select-exercises-label', 'cancel-btn', 'save-btn'
            ];
            
            modalElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = i18n[currentLanguage][elementId.replace(/-/g, '')];
            });
            
            // æ›´æ–°åº·å¤åŠ¨ä½œåç§°
            const exerciseLabels = [
                'shoulder_flexion_label', 'shoulder_abduction_label', 
                'elbow_flexion_label', 'wrist_flexion_label', 'arm_rotation_label'
            ];
            
            exerciseLabels.forEach(labelId => {
                const element = document.getElementById(labelId);
                if (element) element.textContent = i18n[currentLanguage][labelId.replace('_label', '')];
            });
            
            // æ›´æ–°èƒ½åŠ›åˆ†æç›¸å…³æ–‡æœ¬
            const abilityElements = [
                'ability-analysis-title', 'ability-analysis-subtitle', 'analyze-ability-btn-text',
                'ability-modal-title', 'close-ability-btn', 'apply-recommendations-btn'
            ];
            
            abilityElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = i18n[currentLanguage][elementId];
            });
            
            // æ›´æ–°æ™ºèƒ½è®­ç»ƒç›¸å…³æ–‡æœ¬
            const smartTrainingElements = [
                'smart-training-title', 'smart-training-subtitle', 'smart-training-description'
            ];
            
            smartTrainingElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = i18n[currentLanguage][elementId];
            });
            
            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.title = i18n[currentLanguage].pageTitle;
            
            // æ›´æ–°è®­ç»ƒè®¡åˆ’åˆ—è¡¨
            if (typeof loadExerciseList === 'function') {
                loadExerciseList();
            }
            
            // æ›´æ–°å›¾è¡¨æ ‡ç­¾
            if (typeof updateChartLanguage === 'function') {
                updateChartLanguage();
            }
        }

        // ========== æ‚£è€…èƒ½åŠ›åˆ†æåŠŸèƒ½ ==========
        async function analyzePatientAbility() {
            try {
                showTemporaryMessage(
                    currentLanguage === 'zh' ? 'æ­£åœ¨åˆ†ææ‚¨çš„èƒ½åŠ›æ°´å¹³...' : 'Analyzing your ability level...',
                    'info'
                );

                const patientId = document.getElementById('patientName').value || 'default_patient';
                
                const response = await fetch(API_BASE_URL+'/analyze_ability', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        patient_id: patientId,
                        category: 'upper_limb'
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.status === 'success') {
                    displayAbilityAnalysis(data.ability_analysis);
                    showAbilityAnalysisModal();
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
                
            } catch (error) {
                console.error('èƒ½åŠ›åˆ†æå¤±è´¥:', error);
                // ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                useFallbackAbilityAnalysis();
            }
        }

        function displayAbilityAnalysis(analysis) {
            // æ›´æ–°åº·å¤è®¡åˆ’åŒºåŸŸçš„ç®€è¦æ˜¾ç¤º
            const abilityDisplay = document.getElementById('abilityDisplay');
            if (abilityDisplay) {
                const levelText = currentLanguage === 'zh' ? 
                    getChineseAbilityLevel(analysis.ability_level) : 
                    analysis.ability_level;
                    
                abilityDisplay.innerHTML = `
                    <div class="text-center py-2">
                        <div class="text-lg font-bold mb-1">${levelText}</div>
                        <div class="text-sm opacity-80">ç½®ä¿¡åº¦: ${(analysis.confidence * 100).toFixed(0)}%</div>
                        <div class="text-xs mt-1">é¢„è®¡åº·å¤å‘¨æœŸ: ${analysis.estimated_recovery_weeks}å‘¨</div>
                    </div>
                `;
            }
            
            // æ›´æ–°æ¨¡æ€æ¡†ä¸­çš„è¯¦ç»†ç»“æœ
            const resultElement = document.getElementById('abilityAnalysisResult');
            if (resultElement) {
                resultElement.innerHTML = generateAbilityAnalysisHTML(analysis);
            }
            
            // ä¿å­˜åˆ†æç»“æœä¾›åç»­ä½¿ç”¨
            window.currentAbilityAnalysis = analysis;
        }

        function generateAbilityAnalysisHTML(analysis) {
            const levelText = currentLanguage === 'zh' ? 
                getChineseAbilityLevel(analysis.ability_level) : 
                analysis.ability_level;
            
            let html = `
                <div class="mb-4 p-4 bg-blue-50 rounded-lg">
                    <div class="flex items-center mb-2">
                        <i class="fas fa-user-md text-blue-500 text-xl mr-2"></i>
                        <h3 class="text-lg font-bold">${currentLanguage === 'zh' ? 'èƒ½åŠ›æ°´å¹³è¯„ä¼°' : 'Ability Level Assessment'}</h3>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'èƒ½åŠ›ç­‰çº§' : 'Ability Level'}</div>
                            <div class="font-bold text-blue-700">${levelText}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'è¯„ä¼°ç½®ä¿¡åº¦' : 'Assessment Confidence'}</div>
                            <div class="font-bold">${(analysis.confidence * 100).toFixed(0)}%</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'é¢„è®¡åº·å¤å‘¨æœŸ' : 'Estimated Recovery'}</div>
                            <div class="font-bold">${analysis.estimated_recovery_weeks} ${currentLanguage === 'zh' ? 'å‘¨' : 'weeks'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'è®­ç»ƒå»ºè®®' : 'Training Recommendations'}</div>
                            <div class="font-bold">${analysis.recommendations.length} ${currentLanguage === 'zh' ? 'æ¡' : ''}</div>
                        </div>
                    </div>
                </div>
            `;
            
            // æ€§èƒ½æŒ‡æ ‡
            if (analysis.performance_metrics) {
                html += `
                    <div class="mb-4">
                        <h4 class="font-bold mb-2">${currentLanguage === 'zh' ? 'æ€§èƒ½æŒ‡æ ‡' : 'Performance Metrics'}</h4>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'å¹³å‡å‡†ç¡®ç‡' : 'Average Accuracy'}</div>
                                <div class="font-bold">${(analysis.performance_metrics.average_accuracy * 100).toFixed(1)}%</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'è®­ç»ƒæ¬¡æ•°' : 'Training Sessions'}</div>
                                <div class="font-bold">${analysis.performance_metrics.total_sessions}</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'æœ€ä½³è¿ç»­' : 'Best Streak'}</div>
                                <div class="font-bold">${analysis.performance_metrics.best_streak}</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="text-sm text-gray-600">${currentLanguage === 'zh' ? 'è®­ç»ƒä¸€è‡´æ€§' : 'Training Consistency'}</div>
                                <div class="font-bold">${(analysis.performance_metrics.consistency * 100).toFixed(0)}%</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // è®­ç»ƒå»ºè®®
            html += `
                <div class="mb-4">
                    <h4 class="font-bold mb-2">${currentLanguage === 'zh' ? 'ä¸ªæ€§åŒ–å»ºè®®' : 'Personalized Recommendations'}</h4>
                    <div class="bg-green-50 p-3 rounded-lg">
                        <ul class="list-disc pl-5 space-y-1">
            `;
            
            analysis.recommendations.forEach(rec => {
                const recText = currentLanguage === 'zh' ? 
                    getChineseRecommendation(rec) : rec;
                html += `<li class="text-sm">${recText}</li>`;
            });
            
            html += `
                        </ul>
                    </div>
                </div>
            `;
            
            return html;
        }

        function getChineseAbilityLevel(level) {
            const levels = {
                'beginner': 'åˆçº§',
                'intermediate': 'ä¸­çº§',
                'advanced': 'é«˜çº§'
            };
            return levels[level] || level;
        }

        function getChineseRecommendation(rec) {
            const recommendations = {
                'start_with_basic_exercises': 'ä»åŸºç¡€åŠ¨ä½œå¼€å§‹',
                'focus_on_proper_form': 'ä¸“æ³¨äºæ­£ç¡®çš„å§¿åŠ¿',
                'practice_basic_movements': 'ç»ƒä¹ åŸºç¡€åŠ¨ä½œ',
                'use_mirror_for_feedback': 'ä½¿ç”¨é•œå­è·å–åé¦ˆ',
                'increase_repetition_gradually': 'é€æ¸å¢åŠ é‡å¤æ¬¡æ•°',
                'focus_on_movement_quality': 'æ³¨é‡åŠ¨ä½œè´¨é‡',
                'try_different_exercise_variations': 'å°è¯•ä¸åŒçš„åŠ¨ä½œå˜åŒ–',
                'monitor_fatigue_levels': 'ç›‘æ§ç–²åŠ³ç¨‹åº¦',
                'challenge_with_complex_movements': 'æŒ‘æˆ˜å¤æ‚åŠ¨ä½œ',
                'focus_on_endurance': 'æ³¨é‡è€åŠ›è®­ç»ƒ',
                'incorporate_resistance_training': 'åŠ å…¥é˜»åŠ›è®­ç»ƒ',
                'set_higher_accuracy_targets': 'è®¾å®šæ›´é«˜çš„å‡†ç¡®ç‡ç›®æ ‡',
                'focus_on_accuracy_over_speed': 'æ³¨é‡å‡†ç¡®ç‡è€Œéé€Ÿåº¦',
                'maintain_regular_training_schedule': 'ä¿æŒè§„å¾‹çš„è®­ç»ƒè®¡åˆ’'
            };
            return recommendations[rec] || rec;
        }

        function useFallbackAbilityAnalysis() {
            const fallbackAnalysis = {
                ability_level: "intermediate",
                confidence: 0.75,
                recommendations: [
                    "increase_repetition_gradually",
                    "focus_on_movement_quality",
                    "try_different_exercise_variations"
                ],
                estimated_recovery_weeks: 6,
                performance_metrics: {
                    average_accuracy: 0.75,
                    total_sessions: 5,
                    best_streak: 8,
                    consistency: 0.7
                }
            };
            
            displayAbilityAnalysis(fallbackAnalysis);
            showAbilityAnalysisModal();
            
            showTemporaryMessage(
                currentLanguage === 'zh' ? 
                'ä½¿ç”¨æ¨¡æ‹Ÿèƒ½åŠ›åˆ†ææ•°æ®' : 
                'Using simulated ability analysis data',
                'info'
            );
        }

        function showAbilityAnalysisModal() {
            document.getElementById('abilityAnalysisModal').style.display = 'flex';
        }

        function closeAbilityAnalysisModal() {
            document.getElementById('abilityAnalysisModal').style.display = 'none';
        }

        function applyAbilityRecommendations() {
            if (!window.currentAbilityAnalysis) return;
            
            const analysis = window.currentAbilityAnalysis;
            
            // æ ¹æ®èƒ½åŠ›æ°´å¹³è°ƒæ•´è®­ç»ƒè®¡åˆ’
            updateExercisePlanByAbility(analysis.ability_level);
            
            // å…³é—­æ¨¡æ€æ¡†
            closeAbilityAnalysisModal();
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showTemporaryMessage(
                currentLanguage === 'zh' ? 
                'å·²æ ¹æ®èƒ½åŠ›åˆ†æç»“æœè°ƒæ•´è®­ç»ƒè®¡åˆ’' : 
                'Training plan adjusted based on ability analysis',
                'success'
            );
        }

        function updateExercisePlanByAbility(abilityLevel) {
            let selectedExercises, targetReps, difficulty;
            
            switch(abilityLevel) {
                case 'beginner':
                    selectedExercises = ['elbow_flexion', 'wrist_flexion'];
                    targetReps = 8;
                    difficulty = 'easy';
                    break;
                case 'intermediate':
                    selectedExercises = ['shoulder_flexion', 'elbow_flexion', 'shoulder_abduction'];
                    targetReps = 12;
                    difficulty = 'medium';
                    break;
                case 'advanced':
                    selectedExercises = ['shoulder_flexion', 'shoulder_abduction', 'arm_rotation'];
                    targetReps = 15;
                    difficulty = 'hard';
                    break;
                default:
                    selectedExercises = ['shoulder_flexion', 'elbow_flexion', 'shoulder_abduction'];
                    targetReps = 12;
                    difficulty = 'medium';
            }
            
            // æ›´æ–°è®­ç»ƒè®¡åˆ’
            updateExercisePlan(selectedExercises, targetReps, difficulty);
        }

        // ========== ç»‘å®šå‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸ ==========
        // å°†æ‰€æœ‰éœ€è¦ä»HTMLè°ƒç”¨çš„å‡½æ•°ç»‘å®šåˆ°windowå¯¹è±¡
        window.toggleLanguage = toggleLanguage;
        window.toggleCamera = toggleCamera;
        window.toggleTraining = toggleTraining;
        window.resetTraining = resetTraining;
        window.showCustomizeModal = showCustomizeModal;
        window.closeCustomizeModal = closeCustomizeModal;
        window.saveCustomization = saveCustomization;
        window.loadPublishedModel = loadPublishedModel;
        window.selectExercise = selectExercise;
        window.startSmartTraining = startSmartTraining;
        window.analyzePatientAbility = analyzePatientAbility;
        window.closeAbilityAnalysisModal = closeAbilityAnalysisModal;
        window.applyAbilityRecommendations = applyAbilityRecommendations;
    </script>
</body>
</html>